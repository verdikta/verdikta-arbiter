type = "directrequest"
schemaVersion = 1
name = "{JOB_NAME}"
fromAddress = "{FROM_ADDRESS}"
contractAddress = "{CONTRACT_ADDRESS}"
maxTaskDuration = "300s"
evmChainID = "<CHAIN_ID>"
observationSource = """
    decode_log   [type="ethabidecodelog" \
                 abi="OracleRequest(bytes32 indexed specId, address requester, bytes32 requestId, uint256 payment, address callbackAddr, bytes4 callbackFunctionId, uint256 cancelExpiration, uint256 dataVersion, bytes data)" \
                 data="$(jobRun.logData)" \
                 topics="$(jobRun.logTopics)"]

    decode_cbor  [type="cborparse" data="$(decode_log.data)"]
    
    fetch        [type="bridge" 
                     name="verdikta-ai"
                     timeout="300s" # increase timeout to 300s
                     requestData="{\\"id\\": $(jobSpec.externalJobID), \\"data\\": {\\"cid\\": $(decode_cbor.cid), \\"aggId\\": $(decode_cbor.aggId)}}"]
    

parse_scores [type="jsonparse" path="data,aggregatedScore" data="$(fetch)"]
parse_cid    [type="jsonparse" path="data,justificationCid" data="$(fetch)"]
encode_data  [type="ethabiencode" 
            abi="(bytes32 requestId, uint256[] value, string cid)" 
            data="{ \\"requestId\\": $(decode_log.requestId), \\"value\\": $(parse_scores), \\"cid\\": $(parse_cid) }"]

    encode_tx    [type="ethabiencode" \
             abi="fulfillOracleRequestV(bytes32 requestId, uint256 payment, address callbackAddress, bytes4 callbackFunctionId, uint256 expiration, bytes data)" \
             data="{\\"requestId\\": $(decode_log.requestId), \\"payment\\": $(decode_log.payment), \\"callbackAddress\\": $(decode_log.callbackAddr), \\"callbackFunctionId\\": $(decode_log.callbackFunctionId), \\"expiration\\": $(decode_log.cancelExpiration), \\"data\\": $(encode_data)}"]



    submit_tx [type="ethtx" 
          to="{CONTRACT_ADDRESS}" 
          data="$(encode_tx)" 
          gasLimit="6000000"
          minConfirmations="2"
          evmChainID="<CHAIN_ID>"]

    decode_log -> decode_cbor -> fetch -> parse_scores -> parse_cid -> encode_data -> encode_tx -> submit_tx
    fetch -> encode_data
"""

