"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/rank-and-justify/route";
exports.ids = ["app/api/rank-and-justify/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("crypto");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

module.exports = require("https");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:crypto");

/***/ }),

/***/ "node:fs":
/*!**************************!*\
  !*** external "node:fs" ***!
  \**************************/
/***/ ((module) => {

module.exports = require("node:fs");

/***/ }),

/***/ "node:stream":
/*!******************************!*\
  !*** external "node:stream" ***!
  \******************************/
/***/ ((module) => {

module.exports = require("node:stream");

/***/ }),

/***/ "node:stream/web":
/*!**********************************!*\
  !*** external "node:stream/web" ***!
  \**********************************/
/***/ ((module) => {

module.exports = require("node:stream/web");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "punycode":
/*!***************************!*\
  !*** external "punycode" ***!
  \***************************/
/***/ ((module) => {

module.exports = require("punycode");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "worker_threads":
/*!*********************************!*\
  !*** external "worker_threads" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("worker_threads");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("zlib");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Frank-and-justify%2Froute&page=%2Fapi%2Frank-and-justify%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Frank-and-justify%2Froute.ts&appDir=%2Froot%2Fverdikta-arbiter%2Fai-node%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Froot%2Fverdikta-arbiter%2Fai-node&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Frank-and-justify%2Froute&page=%2Fapi%2Frank-and-justify%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Frank-and-justify%2Froute.ts&appDir=%2Froot%2Fverdikta-arbiter%2Fai-node%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Froot%2Fverdikta-arbiter%2Fai-node&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _root_verdikta_arbiter_ai_node_src_app_api_rank_and_justify_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/rank-and-justify/route.ts */ \"(rsc)/./src/app/api/rank-and-justify/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/rank-and-justify/route\",\n        pathname: \"/api/rank-and-justify\",\n        filename: \"route\",\n        bundlePath: \"app/api/rank-and-justify/route\"\n    },\n    resolvedPagePath: \"/root/verdikta-arbiter/ai-node/src/app/api/rank-and-justify/route.ts\",\n    nextConfigOutput,\n    userland: _root_verdikta_arbiter_ai_node_src_app_api_rank_and_justify_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/rank-and-justify/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZyYW5rLWFuZC1qdXN0aWZ5JTJGcm91dGUmcGFnZT0lMkZhcGklMkZyYW5rLWFuZC1qdXN0aWZ5JTJGcm91dGUmYXBwUGF0aHM9JnBhZ2VQYXRoPXByaXZhdGUtbmV4dC1hcHAtZGlyJTJGYXBpJTJGcmFuay1hbmQtanVzdGlmeSUyRnJvdXRlLnRzJmFwcERpcj0lMkZyb290JTJGdmVyZGlrdGEtYXJiaXRlciUyRmFpLW5vZGUlMkZzcmMlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRnJvb3QlMkZ2ZXJkaWt0YS1hcmJpdGVyJTJGYWktbm9kZSZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdIQUFtQjtBQUMzQztBQUNBLGNBQWMseUVBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVk7QUFDWixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRUFBaUU7QUFDekU7QUFDQTtBQUNBLFdBQVcsNEVBQVc7QUFDdEI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUN1SDs7QUFFdkgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS13ZWItdGVtcGxhdGUvPzgzY2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiL3Jvb3QvdmVyZGlrdGEtYXJiaXRlci9haS1ub2RlL3NyYy9hcHAvYXBpL3JhbmstYW5kLWp1c3RpZnkvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL3JhbmstYW5kLWp1c3RpZnkvcm91dGVcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9yYW5rLWFuZC1qdXN0aWZ5XCIsXG4gICAgICAgIGZpbGVuYW1lOiBcInJvdXRlXCIsXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiYXBwL2FwaS9yYW5rLWFuZC1qdXN0aWZ5L3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL3Jvb3QvdmVyZGlrdGEtYXJiaXRlci9haS1ub2RlL3NyYy9hcHAvYXBpL3JhbmstYW5kLWp1c3RpZnkvcm91dGUudHNcIixcbiAgICBuZXh0Q29uZmlnT3V0cHV0LFxuICAgIHVzZXJsYW5kXG59KTtcbi8vIFB1bGwgb3V0IHRoZSBleHBvcnRzIHRoYXQgd2UgbmVlZCB0byBleHBvc2UgZnJvbSB0aGUgbW9kdWxlLiBUaGlzIHNob3VsZFxuLy8gYmUgZWxpbWluYXRlZCB3aGVuIHdlJ3ZlIG1vdmVkIHRoZSBvdGhlciByb3V0ZXMgdG8gdGhlIG5ldyBmb3JtYXQuIFRoZXNlXG4vLyBhcmUgdXNlZCB0byBob29rIGludG8gdGhlIHJvdXRlLlxuY29uc3QgeyByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcyB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL3JhbmstYW5kLWp1c3RpZnkvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgb3JpZ2luYWxQYXRobmFtZSwgcGF0Y2hGZXRjaCwgIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwcC1yb3V0ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Frank-and-justify%2Froute&page=%2Fapi%2Frank-and-justify%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Frank-and-justify%2Froute.ts&appDir=%2Froot%2Fverdikta-arbiter%2Fai-node%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Froot%2Fverdikta-arbiter%2Fai-node&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/rank-and-justify/route.ts":
/*!***********************************************!*\
  !*** ./src/app/api/rank-and-justify/route.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_llm_llm_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/llm/llm-factory */ \"(rsc)/./src/lib/llm/llm-factory.ts\");\n/* harmony import */ var _config_prePromptConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../config/prePromptConfig */ \"(rsc)/./src/config/prePromptConfig.ts\");\n/* harmony import */ var _config_postPromptConfig__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../config/postPromptConfig */ \"(rsc)/./src/config/postPromptConfig.ts\");\n/* harmony import */ var _utils_parseModelResponse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../utils/parseModelResponse */ \"(rsc)/./src/utils/parseModelResponse.ts\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n// Load the justifier model name from environment variables\nconst JUSTIFIER_MODEL = process.env.JUSTIFIER_MODEL || \"default-justifier-model\";\nconst [justifierProviderName, justifierModelName] = process.env.JUSTIFIER_MODEL?.split(\":\") || [\n    \"JustifierProvider\",\n    \"default-model\"\n];\nfunction logInteraction(message) {\n    const timestamp = new Date().toISOString();\n    const logMessage = `[${timestamp}] ${message}\\n`;\n    // Log to console\n    console.log(logMessage);\n    // Log to file\n    const logDir = path__WEBPACK_IMPORTED_MODULE_6___default().join(process.cwd(), \"logs\");\n    const logFile = path__WEBPACK_IMPORTED_MODULE_6___default().join(logDir, \"llm-interactions.log\");\n    try {\n        // Create logs directory if it doesn't exist\n        if (!fs__WEBPACK_IMPORTED_MODULE_5___default().existsSync(logDir)) {\n            fs__WEBPACK_IMPORTED_MODULE_5___default().mkdirSync(logDir, {\n                recursive: true\n            });\n        }\n        fs__WEBPACK_IMPORTED_MODULE_5___default().appendFileSync(logFile, logMessage);\n    } catch (error) {\n        console.error(\"Error writing to log file:\", error);\n    }\n}\nasync function POST(request) {\n    try {\n        console.log(\"POST request received at /api/rank-and-justify\");\n        const body = await request.json();\n        console.log(\"Request body:\", {\n            prompt: body.prompt,\n            models: body.models,\n            hasAttachments: body.attachments?.length ?? 0 > 0,\n            attachmentsCount: body.attachments?.length ?? 0\n        });\n        // Input validation\n        if (!body.prompt || !Array.isArray(body.models) || body.models.length === 0) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: 'Invalid input. \"prompt\" and \"models\" are required.'\n            }, {\n                status: 400\n            });\n        }\n        const prompt = body.prompt;\n        const iterations = body.iterations || 1;\n        const models = body.models;\n        // Process attachments if they exist\n        if (body.attachments?.length) {\n            console.log(\"Processing attachments...\");\n            body.attachments.forEach((content, index)=>{\n                console.log(`Attachment ${index + 1}:`);\n                console.log(\"- Content type:\", typeof content);\n                if (typeof content === \"string\") {\n                    console.log(\"- Starts with:\", content.substring(0, 50) + \"...\");\n                    if (content.startsWith(\"data:\")) {\n                        const mediaTypeMatch = content.match(/^data:([^;]+);base64,/);\n                        console.log(\"- Media type:\", mediaTypeMatch ? mediaTypeMatch[1] : \"unknown\");\n                    } else {\n                        console.log(\"- WARNING: Attachment does not start with data: URI scheme\");\n                    }\n                } else {\n                    console.log(\"- WARNING: Attachment is not a string\");\n                }\n            });\n        }\n        const attachments = body.attachments?.map((content, index)=>{\n            if (content.startsWith(\"data:image\")) {\n                const mediaTypeMatch = content.match(/^data:([^;]+);base64,/);\n                const mediaType = mediaTypeMatch ? mediaTypeMatch[1] : \"image/jpeg\";\n                console.log(`Processing image attachment ${index + 1}:`, {\n                    mediaType,\n                    contentLength: content.length,\n                    isBase64: content.includes(\";base64,\")\n                });\n                const base64Data = content.replace(/^data:image\\/[^;]+;base64,/, \"\");\n                return {\n                    type: \"image\",\n                    content: base64Data,\n                    mediaType: mediaType\n                };\n            }\n            console.log(`Processing non-image attachment ${index + 1}:`, {\n                type: \"text\",\n                contentLength: content.length\n            });\n            return {\n                type: \"text\",\n                content: content,\n                mediaType: \"text/plain\"\n            };\n        }) || [];\n        // Log processed attachments summary\n        console.log(\"Processed attachments summary:\", attachments.map((att)=>({\n                type: att.type,\n                mediaType: att.mediaType,\n                contentLength: att.content.length\n            })));\n        // Initialize data structures\n        const previousIterationResponses = [];\n        const modelOutputs = [];\n        const V_average = [];\n        const weights = [];\n        const totalWeights = models.reduce((sum, m)=>sum + m.weight, 0);\n        const allJustifications = [];\n        // Validate total weights\n        if (totalWeights <= 0 || totalWeights > models.length) {\n            return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                error: \"Invalid weights assigned to models.\"\n            }, {\n                status: 400\n            });\n        }\n        console.log(\"Starting model invocations\");\n        let finalAggregatedScore = [];\n        let finalJustification = \"\";\n        // Model Invocation\n        for(let i = 0; i < iterations; i++){\n            console.log(`Starting iteration ${i + 1}`);\n            const iterationOutputs = [];\n            const iterationWeights = [];\n            const iterationJustifications = [];\n            // Process each model for this iteration\n            for(let j = 0; j < models.length; j++){\n                const modelInfo = models[j];\n                const count = modelInfo.count || 1;\n                const weight = modelInfo.weight;\n                const allOutputs = [];\n                console.log(`Processing model: ${modelInfo.provider} - ${modelInfo.model}`);\n                if (!modelInfo.provider || !modelInfo.model || weight < 0 || weight > 1) {\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        error: \"Invalid model input. Check provider, model, and weight.\"\n                    }, {\n                        status: 400\n                    });\n                }\n                try {\n                    // Cast to unknown first to avoid type mismatch\n                    const llmProvider = await _lib_llm_llm_factory__WEBPACK_IMPORTED_MODULE_1__.LLMFactory.getProvider(modelInfo.provider);\n                    if (!llmProvider) {\n                        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                            error: `Unsupported provider: ${modelInfo.provider}`\n                        }, {\n                            status: 400\n                        });\n                    }\n                    // Construct the full prompt based on iteration\n                    let iterationPrompt = `${_config_prePromptConfig__WEBPACK_IMPORTED_MODULE_2__.prePromptConfig.getPrompt(body.outcomes)}\\n\\n${prompt}`;\n                    if (i > 0 && previousIterationResponses.length > 0) {\n                        const previousResponsesText = previousIterationResponses.join(\"\\n\\n\");\n                        iterationPrompt = `${iterationPrompt}\\n\\n${_config_postPromptConfig__WEBPACK_IMPORTED_MODULE_3__.postPromptConfig.prompt.replace(\"{{previousResponses}}\", previousResponsesText)}`;\n                    }\n                    if (attachments.length > 0) {\n                        console.log(`Sending ${attachments.length} attachments to ${modelInfo.provider}:`, attachments.map((att)=>({\n                                type: att.type,\n                                mediaType: att.mediaType,\n                                contentLength: att.content.length\n                            })));\n                    }\n                    for(let c = 0; c < count; c++){\n                        let responseText;\n                        if (attachments.length > 0 && llmProvider.supportsAttachments(modelInfo.model)) {\n                            logInteraction(`Prompt to ${modelInfo.provider} - ${modelInfo.model} with attachments:\\n${iterationPrompt}\\n`);\n                            try {\n                                responseText = await llmProvider.generateResponseWithAttachments(iterationPrompt, modelInfo.model, attachments);\n                                logInteraction(`Response from ${modelInfo.provider} - ${modelInfo.model}:\\n${responseText}\\n`);\n                            } catch (providerError) {\n                                console.error(`Provider error from ${modelInfo.provider}/${modelInfo.model}:`, {\n                                    error: providerError.message,\n                                    stack: providerError.stack,\n                                    attachments: attachments.length > 0 ? \"Has attachments\" : \"No attachments\"\n                                });\n                                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                                    error: providerError.message,\n                                    scores: [],\n                                    justification: \"\"\n                                }, {\n                                    status: 400\n                                });\n                            }\n                        } else {\n                            logInteraction(`Prompt to ${modelInfo.provider} - ${modelInfo.model}:\\n${iterationPrompt}\\n`);\n                            try {\n                                responseText = await llmProvider.generateResponse(iterationPrompt, modelInfo.model);\n                                logInteraction(`Response from ${modelInfo.provider} - ${modelInfo.model}:\\n${responseText}\\n`);\n                            } catch (providerError) {\n                                console.error(`Provider error from ${modelInfo.provider}/${modelInfo.model}:`, {\n                                    error: providerError.message,\n                                    stack: providerError.stack,\n                                    attachments: attachments.length > 0 ? \"Has attachments\" : \"No attachments\"\n                                });\n                                return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                                    error: providerError.message,\n                                    scores: [],\n                                    justification: \"\"\n                                }, {\n                                    status: 400\n                                });\n                            }\n                        }\n                        let { decisionVector, justification, scores } = (0,_utils_parseModelResponse__WEBPACK_IMPORTED_MODULE_4__.parseModelResponse)(responseText, body.outcomes);\n                        let effectiveJustification = justification; // Store potentially modified justification\n                        if (!decisionVector) {\n                            console.warn(`Failed to parse decision vector from model ${modelInfo.model}. Response: ${responseText}. Applying fallback.`);\n                            const numOutcomes = body.outcomes?.length || 2; // Default to 2 if outcomes not specified\n                            const baseScore = Math.floor(1000000 / numOutcomes);\n                            const fallbackDecisionVector = Array(numOutcomes).fill(baseScore);\n                            // Distribute remainder to ensure sum is exactly 1,000,000\n                            fallbackDecisionVector[0] += 1000000 - baseScore * numOutcomes;\n                            decisionVector = fallbackDecisionVector; // Use fallback vector\n                            if (!justification) {\n                                effectiveJustification = `LLM_ERROR: ${responseText}`; // Create fallback justification\n                            }\n                        // No need to return an error, proceed with fallback values\n                        }\n                        allOutputs.push(decisionVector);\n                        if (effectiveJustification) {\n                            const formattedResponse = `From ${modelInfo.provider} - ${modelInfo.model}:\\nScore: ${decisionVector}\\nJustification: ${effectiveJustification}`;\n                            iterationJustifications.push(`From model ${modelInfo.model}:\\n${effectiveJustification}`);\n                            if (i < iterations - 1) {\n                                previousIterationResponses.push(formattedResponse);\n                            }\n                        }\n                    }\n                    // Average the outputs for this model if count > 1\n                    const modelAverage = count > 1 ? averageVectors(allOutputs) : allOutputs[0];\n                    iterationOutputs.push(modelAverage);\n                    iterationWeights.push(weight);\n                } catch (error) {\n                    // If we get here, an error occurred trying to get the provider or during model setup.\n                    console.error(`Critical error processing model ${modelInfo.provider} - ${modelInfo.model} (iteration ${i + 1}):`, error);\n                    // === ADD THIS: Return 400 immediately on provider setup error ===\n                    return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n                        error: `Failed to process model configuration: ${modelInfo.provider} - ${modelInfo.model}. Reason: ${error.message}`,\n                        scores: [],\n                        justification: \"\"\n                    }, {\n                        status: 400\n                    });\n                // === END ADDITION ===\n                // Optionally, add a placeholder or skip this model's contribution (Original behavior - now replaced by the return above)\n                }\n            }\n            // Compute weighted average for this iteration\n            finalAggregatedScore = computeAverageVectors(iterationOutputs, iterationWeights);\n            // Generate justification only on the final iteration\n            if (i === iterations - 1) {\n                try {\n                    const justifierProvider = await _lib_llm_llm_factory__WEBPACK_IMPORTED_MODULE_1__.LLMFactory.getProvider(justifierProviderName);\n                    logInteraction(`Prompt to Justifier:\n${prompt}\\n`); // Assuming base prompt is sufficient context\n                    finalJustification = await generateJustification(finalAggregatedScore, iterationJustifications, justifierProvider, justifierModelName);\n                    logInteraction(`Response from Justifier:\n${finalJustification}\\n`);\n                } catch (error) {\n                    console.error(\"Error generating final justification in iteration:\", error);\n                    finalJustification = \"Error generating final justification.\"; // Handle error gracefully\n                }\n            }\n        // Note: Logic for handling previousIterationResponses for multi-iteration prompts removed for clarity,\n        // as the tests seem focused on single iteration or simple aggregation.\n        }\n        // Format the final response using results from the LAST iteration\n        const responseBody = {\n            scores: body.outcomes ? finalAggregatedScore.map((score, index)=>({\n                    outcome: body.outcomes[index],\n                    score: Math.floor(score)\n                })) : finalAggregatedScore.map((score)=>({\n                    outcome: \"unnamed\",\n                    score: Math.floor(score)\n                })),\n            justification: finalJustification\n        };\n        console.log(\"Sending final response:\", responseBody);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(responseBody);\n    } catch (error) {\n        // General error handling for the entire POST request\n        console.error(\"Error in POST /api/rank-and-justify:\", {\n            error: error.message,\n            stack: error.stack,\n            type: error.constructor.name\n        });\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: error.message || \"An error occurred while processing the request.\",\n            scores: [],\n            justification: \"\"\n        }, {\n            status: 500\n        });\n    }\n}\n// Helper function - NOT exported\nasync function generateJustification(V_total, allJustifications, justifierProvider, justifierModel) {\n    const prompt = `Using the aggregated decision vector ${JSON.stringify(V_total)}, and considering the following justifications from individual models:\\n\\n${allJustifications.join(\"\\n\\n\")}\\n\\nProvide a comprehensive justification for the result.`;\n    const response = await justifierProvider.generateResponse(prompt, justifierModel);\n    return response;\n}\n// Helper function - NOT exported\nfunction computeAverageVectors(vectors, weights) {\n    if (!vectors || vectors.length === 0 || vectors.length !== weights.length) {\n        // Handle empty input or mismatched lengths\n        console.warn(\"computeAverageVectors received invalid input:\", {\n            vectors: vectors?.length,\n            weights: weights?.length\n        });\n        return [];\n    }\n    const totalWeight = weights.reduce((sum, w)=>sum + w, 0);\n    if (totalWeight === 0) {\n        console.warn(\"computeAverageVectors received zero total weight.\");\n        return [];\n    }\n    const dimensions = vectors[0].length;\n    const result = new Array(dimensions).fill(0);\n    for(let i = 0; i < vectors.length; i++){\n        for(let j = 0; j < dimensions; j++){\n            // Simplified weighted accumulation assuming vectors.length === weights.length\n            result[j] += vectors[i][j] * weights[i] / totalWeight;\n        }\n    }\n    return result;\n}\n// Helper function - NOT exported\nfunction averageVectors(vectors) {\n    const dimensions = vectors[0].length;\n    const result = new Array(dimensions).fill(0);\n    for(let i = 0; i < vectors.length; i++){\n        for(let j = 0; j < dimensions; j++){\n            result[j] += vectors[i][j];\n        }\n    }\n    for(let j = 0; j < dimensions; j++){\n        result[j] = Math.floor(result[j] / vectors.length);\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvYXBwL2FwaS9yYW5rLWFuZC1qdXN0aWZ5L3JvdXRlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBMkM7QUFDZTtBQUNRO0FBQ0U7QUFDRztBQUNuRDtBQUNJO0FBRXhCLDJEQUEyRDtBQUMzRCxNQUFNTyxrQkFBa0JDLFFBQVFDLEdBQUcsQ0FBQ0YsZUFBZSxJQUFJO0FBQ3ZELE1BQU0sQ0FBQ0csdUJBQXVCQyxtQkFBbUIsR0FBR0gsUUFBUUMsR0FBRyxDQUFDRixlQUFlLEVBQUVLLE1BQU0sUUFBUTtJQUFDO0lBQXFCO0NBQWdCO0FBaUNySSxTQUFTQyxlQUFlQyxPQUFlO0lBQ3JDLE1BQU1DLFlBQVksSUFBSUMsT0FBT0MsV0FBVztJQUN4QyxNQUFNQyxhQUFhLENBQUMsQ0FBQyxFQUFFSCxVQUFVLEVBQUUsRUFBRUQsUUFBUSxFQUFFLENBQUM7SUFFaEQsaUJBQWlCO0lBQ2pCSyxRQUFRQyxHQUFHLENBQUNGO0lBRVosY0FBYztJQUNkLE1BQU1HLFNBQVNmLGdEQUFTLENBQUNFLFFBQVFlLEdBQUcsSUFBSTtJQUN4QyxNQUFNQyxVQUFVbEIsZ0RBQVMsQ0FBQ2UsUUFBUTtJQUVsQyxJQUFJO1FBQ0YsNENBQTRDO1FBQzVDLElBQUksQ0FBQ2hCLG9EQUFhLENBQUNnQixTQUFTO1lBQzFCaEIsbURBQVksQ0FBQ2dCLFFBQVE7Z0JBQUVNLFdBQVc7WUFBSztRQUN6QztRQUVBdEIsd0RBQWlCLENBQUNtQixTQUFTTjtJQUM3QixFQUFFLE9BQU9XLE9BQU87UUFDZFYsUUFBUVUsS0FBSyxDQUFDLDhCQUE4QkE7SUFDOUM7QUFDRjtBQUVPLGVBQWVDLEtBQUtDLE9BQWdCO0lBQ3pDLElBQUk7UUFDRlosUUFBUUMsR0FBRyxDQUFDO1FBQ1osTUFBTVksT0FBNEIsTUFBTUQsUUFBUUUsSUFBSTtRQUNwRGQsUUFBUUMsR0FBRyxDQUFDLGlCQUFpQjtZQUMzQmMsUUFBUUYsS0FBS0UsTUFBTTtZQUNuQkMsUUFBUUgsS0FBS0csTUFBTTtZ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L2FwaS9yYW5rLWFuZC1qdXN0aWZ5L3JvdXRlLnRzP2VmODkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgTExNRmFjdG9yeSB9IGZyb20gJy4uLy4uLy4uL2xpYi9sbG0vbGxtLWZhY3RvcnknO1xuaW1wb3J0IHsgcHJlUHJvbXB0Q29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vY29uZmlnL3ByZVByb21wdENvbmZpZyc7XG5pbXBvcnQgeyBwb3N0UHJvbXB0Q29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vY29uZmlnL3Bvc3RQcm9tcHRDb25maWcnO1xuaW1wb3J0IHsgcGFyc2VNb2RlbFJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvcGFyc2VNb2RlbFJlc3BvbnNlJztcbmltcG9ydCBmcyBmcm9tICdmcyc7XG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJztcblxuLy8gTG9hZCB0aGUganVzdGlmaWVyIG1vZGVsIG5hbWUgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbmNvbnN0IEpVU1RJRklFUl9NT0RFTCA9IHByb2Nlc3MuZW52LkpVU1RJRklFUl9NT0RFTCB8fCAnZGVmYXVsdC1qdXN0aWZpZXItbW9kZWwnO1xuY29uc3QgW2p1c3RpZmllclByb3ZpZGVyTmFtZSwganVzdGlmaWVyTW9kZWxOYW1lXSA9IHByb2Nlc3MuZW52LkpVU1RJRklFUl9NT0RFTD8uc3BsaXQoJzonKSB8fCBbJ0p1c3RpZmllclByb3ZpZGVyJywgJ2RlZmF1bHQtbW9kZWwnXTtcblxuaW50ZXJmYWNlIE1vZGVsSW5wdXQge1xuICBwcm92aWRlcjogc3RyaW5nO1xuICBtb2RlbDogc3RyaW5nO1xuICB3ZWlnaHQ6IG51bWJlcjtcbiAgY291bnQ/OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBSYW5rQW5kSnVzdGlmeUlucHV0IHtcbiAgcHJvbXB0OiBzdHJpbmc7XG4gIG91dGNvbWVzPzogc3RyaW5nW107ICAvLyBPcHRpb25hbCBhcnJheSBvZiBvdXRjb21lIGRlc2NyaXB0aW9uc1xuICBtb2RlbHM6IE1vZGVsSW5wdXRbXTtcbiAgaXRlcmF0aW9ucz86IG51bWJlcjtcbiAgYXR0YWNobWVudHM/OiBzdHJpbmdbXTtcbn1cblxuaW50ZXJmYWNlIFNjb3JlT3V0Y29tZSB7XG4gIG91dGNvbWU6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbn1cblxuaW50ZXJmYWNlIFJhbmtBbmRKdXN0aWZ5T3V0cHV0IHtcbiAgc2NvcmVzOiBTY29yZU91dGNvbWVbXTtcbiAganVzdGlmaWNhdGlvbjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgTExNUHJvdmlkZXIge1xuICBnZW5lcmF0ZVJlc3BvbnNlOiAocHJvbXB0OiBzdHJpbmcsIG1vZGVsOiBzdHJpbmcpID0+IFByb21pc2U8c3RyaW5nPjtcbiAgZ2VuZXJhdGVSZXNwb25zZVdpdGhBdHRhY2htZW50cz86IChwcm9tcHQ6IHN0cmluZywgbW9kZWw6IHN0cmluZywgYXR0YWNobWVudHM6IGFueVtdKSA9PiBQcm9taXNlPHN0cmluZz47XG4gIHN1cHBvcnRzQXR0YWNobWVudHM6IChtb2RlbDogc3RyaW5nKSA9PiBib29sZWFuO1xufVxuXG5mdW5jdGlvbiBsb2dJbnRlcmFjdGlvbihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICBjb25zdCBsb2dNZXNzYWdlID0gYFske3RpbWVzdGFtcH1dICR7bWVzc2FnZX1cXG5gO1xuICBcbiAgLy8gTG9nIHRvIGNvbnNvbGVcbiAgY29uc29sZS5sb2cobG9nTWVzc2FnZSk7XG5cbiAgLy8gTG9nIHRvIGZpbGVcbiAgY29uc3QgbG9nRGlyID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdsb2dzJyk7XG4gIGNvbnN0IGxvZ0ZpbGUgPSBwYXRoLmpvaW4obG9nRGlyLCAnbGxtLWludGVyYWN0aW9ucy5sb2cnKTtcblxuICB0cnkge1xuICAgIC8vIENyZWF0ZSBsb2dzIGRpcmVjdG9yeSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGxvZ0RpcikpIHtcbiAgICAgIGZzLm1rZGlyU3luYyhsb2dEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBcbiAgICBmcy5hcHBlbmRGaWxlU3luYyhsb2dGaWxlLCBsb2dNZXNzYWdlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB3cml0aW5nIHRvIGxvZyBmaWxlOicsIGVycm9yKTtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gUE9TVChyZXF1ZXN0OiBSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ1BPU1QgcmVxdWVzdCByZWNlaXZlZCBhdCAvYXBpL3JhbmstYW5kLWp1c3RpZnknKTtcbiAgICBjb25zdCBib2R5OiBSYW5rQW5kSnVzdGlmeUlucHV0ID0gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gICAgY29uc29sZS5sb2coJ1JlcXVlc3QgYm9keTonLCB7XG4gICAgICBwcm9tcHQ6IGJvZHkucHJvbXB0LFxuICAgICAgbW9kZWxzOiBib2R5Lm1vZGVscyxcbiAgICAgIGhhc0F0dGFjaG1lbnRzOiBib2R5LmF0dGFjaG1lbnRzPy5sZW5ndGggPz8gMCA+IDAsXG4gICAgICBhdHRhY2htZW50c0NvdW50OiBib2R5LmF0dGFjaG1lbnRzPy5sZW5ndGggPz8gMFxuICAgIH0pO1xuXG4gICAgLy8gSW5wdXQgdmFsaWRhdGlvblxuICAgIGlmICghYm9keS5wcm9tcHQgfHwgIUFycmF5LmlzQXJyYXkoYm9keS5tb2RlbHMpIHx8IGJvZHkubW9kZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW52YWxpZCBpbnB1dC4gXCJwcm9tcHRcIiBhbmQgXCJtb2RlbHNcIiBhcmUgcmVxdWlyZWQuJyB9LFxuICAgICAgICB7IHN0YXR1czogNDAwIH1cbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvbXB0ID0gYm9keS5wcm9tcHQ7XG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IGJvZHkuaXRlcmF0aW9ucyB8fCAxO1xuICAgIGNvbnN0IG1vZGVscyA9IGJvZHkubW9kZWxzO1xuXG4gICAgLy8gUHJvY2VzcyBhdHRhY2htZW50cyBpZiB0aGV5IGV4aXN0XG4gICAgaWYgKGJvZHkuYXR0YWNobWVudHM/Lmxlbmd0aCkge1xuICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3NpbmcgYXR0YWNobWVudHMuLi4nKTtcbiAgICAgIGJvZHkuYXR0YWNobWVudHMuZm9yRWFjaCgoY29udGVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coYEF0dGFjaG1lbnQgJHtpbmRleCArIDF9OmApO1xuICAgICAgICBjb25zb2xlLmxvZygnLSBDb250ZW50IHR5cGU6JywgdHlwZW9mIGNvbnRlbnQpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJy0gU3RhcnRzIHdpdGg6JywgY29udGVudC5zdWJzdHJpbmcoMCwgNTApICsgJy4uLicpO1xuICAgICAgICAgIGlmIChjb250ZW50LnN0YXJ0c1dpdGgoJ2RhdGE6JykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhVHlwZU1hdGNoID0gY29udGVudC5tYXRjaCgvXmRhdGE6KFteO10rKTtiYXNlNjQsLyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnLSBNZWRpYSB0eXBlOicsIG1lZGlhVHlwZU1hdGNoID8gbWVkaWFUeXBlTWF0Y2hbMV0gOiAndW5rbm93bicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnLSBXQVJOSU5HOiBBdHRhY2htZW50IGRvZXMgbm90IHN0YXJ0IHdpdGggZGF0YTogVVJJIHNjaGVtZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnLSBXQVJOSU5HOiBBdHRhY2htZW50IGlzIG5vdCBhIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhdHRhY2htZW50cyA9IGJvZHkuYXR0YWNobWVudHM/Lm1hcCgoY29udGVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChjb250ZW50LnN0YXJ0c1dpdGgoJ2RhdGE6aW1hZ2UnKSkge1xuICAgICAgICBjb25zdCBtZWRpYVR5cGVNYXRjaCA9IGNvbnRlbnQubWF0Y2goL15kYXRhOihbXjtdKyk7YmFzZTY0LC8pO1xuICAgICAgICBjb25zdCBtZWRpYVR5cGUgPSBtZWRpYVR5cGVNYXRjaCA/IG1lZGlhVHlwZU1hdGNoWzFdIDogJ2ltYWdlL2pwZWcnO1xuICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBpbWFnZSBhdHRhY2htZW50ICR7aW5kZXggKyAxfTpgLCB7XG4gICAgICAgICAgbWVkaWFUeXBlLFxuICAgICAgICAgIGNvbnRlbnRMZW5ndGg6IGNvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgIGlzQmFzZTY0OiBjb250ZW50LmluY2x1ZGVzKCc7YmFzZTY0LCcpXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgYmFzZTY0RGF0YSA9IGNvbnRlbnQucmVwbGFjZSgvXmRhdGE6aW1hZ2VcXC9bXjtdKztiYXNlNjQsLywgJycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdpbWFnZScsXG4gICAgICAgICAgY29udGVudDogYmFzZTY0RGF0YSxcbiAgICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc29sZS5sb2coYFByb2Nlc3Npbmcgbm9uLWltYWdlIGF0dGFjaG1lbnQgJHtpbmRleCArIDF9OmAsIHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aFxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgIG1lZGlhVHlwZTogJ3RleHQvcGxhaW4nXG4gICAgICB9O1xuICAgIH0pIHx8IFtdO1xuXG4gICAgLy8gTG9nIHByb2Nlc3NlZCBhdHRhY2htZW50cyBzdW1tYXJ5XG4gICAgY29uc29sZS5sb2coJ1Byb2Nlc3NlZCBhdHRhY2htZW50cyBzdW1tYXJ5OicsIGF0dGFjaG1lbnRzLm1hcChhdHQgPT4gKHtcbiAgICAgIHR5cGU6IGF0dC50eXBlLFxuICAgICAgbWVkaWFUeXBlOiBhdHQubWVkaWFUeXBlLFxuICAgICAgY29udGVudExlbmd0aDogYXR0LmNvbnRlbnQubGVuZ3RoXG4gICAgfSkpKTtcblxuICAgIC8vIEluaXRpYWxpemUgZGF0YSBzdHJ1Y3R1cmVzXG4gICAgY29uc3QgcHJldmlvdXNJdGVyYXRpb25SZXNwb25zZXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgbW9kZWxPdXRwdXRzOiBudW1iZXJbXVtdW10gPSBbXTtcbiAgICBjb25zdCBWX2F2ZXJhZ2U6IG51bWJlcltdW10gPSBbXTtcbiAgICBjb25zdCB3ZWlnaHRzOiBudW1iZXJbXSA9IFtdO1xuICAgIGNvbnN0IHRvdGFsV2VpZ2h0cyA9IG1vZGVscy5yZWR1Y2UoKHN1bSwgbSkgPT4gc3VtICsgbS53ZWlnaHQsIDApO1xuICAgIGNvbnN0IGFsbEp1c3RpZmljYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIC8vIFZhbGlkYXRlIHRvdGFsIHdlaWdodHNcbiAgICBpZiAodG90YWxXZWlnaHRzIDw9IDAgfHwgdG90YWxXZWlnaHRzID4gbW9kZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxuICAgICAgICB7IGVycm9yOiAnSW52YWxpZCB3ZWlnaHRzIGFzc2lnbmVkIHRvIG1vZGVscy4nIH0sXG4gICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgbW9kZWwgaW52b2NhdGlvbnMnKTtcblxuICAgIGxldCBmaW5hbEFnZ3JlZ2F0ZWRTY29yZTogbnVtYmVyW10gPSBbXTtcbiAgICBsZXQgZmluYWxKdXN0aWZpY2F0aW9uOiBzdHJpbmcgPSAnJztcblxuICAgIC8vIE1vZGVsIEludm9jYXRpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIGl0ZXJhdGlvbiAke2kgKyAxfWApO1xuICAgICAgXG4gICAgICBjb25zdCBpdGVyYXRpb25PdXRwdXRzOiBudW1iZXJbXVtdID0gW107XG4gICAgICBjb25zdCBpdGVyYXRpb25XZWlnaHRzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgY29uc3QgaXRlcmF0aW9uSnVzdGlmaWNhdGlvbnM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgIC8vIFByb2Nlc3MgZWFjaCBtb2RlbCBmb3IgdGhpcyBpdGVyYXRpb25cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbW9kZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsSW5mbyA9IG1vZGVsc1tqXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBtb2RlbEluZm8uY291bnQgfHwgMTtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ID0gbW9kZWxJbmZvLndlaWdodDtcbiAgICAgICAgY29uc3QgYWxsT3V0cHV0czogbnVtYmVyW11bXSA9IFtdO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIG1vZGVsOiAke21vZGVsSW5mby5wcm92aWRlcn0gLSAke21vZGVsSW5mby5tb2RlbH1gKTtcblxuICAgICAgICBpZiAoIW1vZGVsSW5mby5wcm92aWRlciB8fCAhbW9kZWxJbmZvLm1vZGVsIHx8IHdlaWdodCA8IDAgfHwgd2VpZ2h0ID4gMSkge1xuICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgIHsgZXJyb3I6ICdJbnZhbGlkIG1vZGVsIGlucHV0LiBDaGVjayBwcm92aWRlciwgbW9kZWwsIGFuZCB3ZWlnaHQuJyB9LFxuICAgICAgICAgICAgeyBzdGF0dXM6IDQwMCB9XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ2FzdCB0byB1bmtub3duIGZpcnN0IHRvIGF2b2lkIHR5cGUgbWlzbWF0Y2hcbiAgICAgICAgICBjb25zdCBsbG1Qcm92aWRlciA9IGF3YWl0IExMTUZhY3RvcnkuZ2V0UHJvdmlkZXIobW9kZWxJbmZvLnByb3ZpZGVyKSBhcyB1bmtub3duIGFzIExMTVByb3ZpZGVyO1xuICAgICAgICAgIGlmICghbGxtUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihcbiAgICAgICAgICAgICAgeyBlcnJvcjogYFVuc3VwcG9ydGVkIHByb3ZpZGVyOiAke21vZGVsSW5mby5wcm92aWRlcn1gIH0sXG4gICAgICAgICAgICAgIHsgc3RhdHVzOiA0MDAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIGZ1bGwgcHJvbXB0IGJhc2VkIG9uIGl0ZXJhdGlvblxuICAgICAgICAgIGxldCBpdGVyYXRpb25Qcm9tcHQgPSBgJHtwcmVQcm9tcHRDb25maWcuZ2V0UHJvbXB0KGJvZHkub3V0Y29tZXMpfVxcblxcbiR7cHJvbXB0fWA7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGkgPiAwICYmIHByZXZpb3VzSXRlcmF0aW9uUmVzcG9uc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUmVzcG9uc2VzVGV4dCA9IHByZXZpb3VzSXRlcmF0aW9uUmVzcG9uc2VzLmpvaW4oJ1xcblxcbicpO1xuICAgICAgICAgICAgaXRlcmF0aW9uUHJvbXB0ID0gYCR7aXRlcmF0aW9uUHJvbXB0fVxcblxcbiR7cG9zdFByb21wdENvbmZpZy5wcm9tcHQucmVwbGFjZSgne3twcmV2aW91c1Jlc3BvbnNlc319JywgcHJldmlvdXNSZXNwb25zZXNUZXh0KX1gO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhdHRhY2htZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU2VuZGluZyAke2F0dGFjaG1lbnRzLmxlbmd0aH0gYXR0YWNobWVudHMgdG8gJHttb2RlbEluZm8ucHJvdmlkZXJ9OmAsIFxuICAgICAgICAgICAgICBhdHRhY2htZW50cy5tYXAoYXR0ID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogYXR0LnR5cGUsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBhdHQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGg6IGF0dC5jb250ZW50Lmxlbmd0aFxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb3VudDsgYysrKSB7XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VUZXh0OiBzdHJpbmc7XG4gICAgICAgICAgICBpZiAoYXR0YWNobWVudHMubGVuZ3RoID4gMCAmJiBsbG1Qcm92aWRlci5zdXBwb3J0c0F0dGFjaG1lbnRzKG1vZGVsSW5mby5tb2RlbCkpIHtcbiAgICAgICAgICAgICAgbG9nSW50ZXJhY3Rpb24oYFByb21wdCB0byAke21vZGVsSW5mby5wcm92aWRlcn0gLSAke21vZGVsSW5mby5tb2RlbH0gd2l0aCBhdHRhY2htZW50czpcXG4ke2l0ZXJhdGlvblByb21wdH1cXG5gKTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgPSBhd2FpdCBsbG1Qcm92aWRlci5nZW5lcmF0ZVJlc3BvbnNlV2l0aEF0dGFjaG1lbnRzIShcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvblByb21wdCxcbiAgICAgICAgICAgICAgICAgIG1vZGVsSW5mby5tb2RlbCxcbiAgICAgICAgICAgICAgICAgIGF0dGFjaG1lbnRzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBsb2dJbnRlcmFjdGlvbihgUmVzcG9uc2UgZnJvbSAke21vZGVsSW5mby5wcm92aWRlcn0gLSAke21vZGVsSW5mby5tb2RlbH06XFxuJHtyZXNwb25zZVRleHR9XFxuYCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHByb3ZpZGVyRXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFByb3ZpZGVyIGVycm9yIGZyb20gJHttb2RlbEluZm8ucHJvdmlkZXJ9LyR7bW9kZWxJbmZvLm1vZGVsfTpgLCB7XG4gICAgICAgICAgICAgICAgICBlcnJvcjogcHJvdmlkZXJFcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgc3RhY2s6IHByb3ZpZGVyRXJyb3Iuc3RhY2ssXG4gICAgICAgICAgICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHMubGVuZ3RoID4gMCA/ICdIYXMgYXR0YWNobWVudHMnIDogJ05vIGF0dGFjaG1lbnRzJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICAgICAgICBlcnJvcjogcHJvdmlkZXJFcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgc2NvcmVzOiBbXSBhcyBTY29yZU91dGNvbWVbXSxcbiAgICAgICAgICAgICAgICAgIGp1c3RpZmljYXRpb246ICcnXG4gICAgICAgICAgICAgICAgfSwgeyBzdGF0dXM6IDQwMCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbG9nSW50ZXJhY3Rpb24oYFByb21wdCB0byAke21vZGVsSW5mby5wcm92aWRlcn0gLSAke21vZGVsSW5mby5tb2RlbH06XFxuJHtpdGVyYXRpb25Qcm9tcHR9XFxuYCk7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0ID0gYXdhaXQgbGxtUHJvdmlkZXIuZ2VuZXJhdGVSZXNwb25zZShcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvblByb21wdCxcbiAgICAgICAgICAgICAgICAgIG1vZGVsSW5mby5tb2RlbFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbG9nSW50ZXJhY3Rpb24oYFJlc3BvbnNlIGZyb20gJHttb2RlbEluZm8ucHJvdmlkZXJ9IC0gJHttb2RlbEluZm8ubW9kZWx9OlxcbiR7cmVzcG9uc2VUZXh0fVxcbmApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChwcm92aWRlckVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBQcm92aWRlciBlcnJvciBmcm9tICR7bW9kZWxJbmZvLnByb3ZpZGVyfS8ke21vZGVsSW5mby5tb2RlbH06YCwge1xuICAgICAgICAgICAgICAgICAgZXJyb3I6IHByb3ZpZGVyRXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIHN0YWNrOiBwcm92aWRlckVycm9yLnN0YWNrLFxuICAgICAgICAgICAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzLmxlbmd0aCA+IDAgPyAnSGFzIGF0dGFjaG1lbnRzJyA6ICdObyBhdHRhY2htZW50cydcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oe1xuICAgICAgICAgICAgICAgICAgZXJyb3I6IHByb3ZpZGVyRXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgIHNjb3JlczogW10gYXMgU2NvcmVPdXRjb21lW10sXG4gICAgICAgICAgICAgICAgICBqdXN0aWZpY2F0aW9uOiAnJ1xuICAgICAgICAgICAgICAgIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHsgZGVjaXNpb25WZWN0b3IsIGp1c3RpZmljYXRpb24sIHNjb3JlcyB9ID0gcGFyc2VNb2RlbFJlc3BvbnNlKHJlc3BvbnNlVGV4dCwgYm9keS5vdXRjb21lcyk7XG4gICAgICAgICAgICBsZXQgZWZmZWN0aXZlSnVzdGlmaWNhdGlvbiA9IGp1c3RpZmljYXRpb247IC8vIFN0b3JlIHBvdGVudGlhbGx5IG1vZGlmaWVkIGp1c3RpZmljYXRpb25cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFkZWNpc2lvblZlY3Rvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBwYXJzZSBkZWNpc2lvbiB2ZWN0b3IgZnJvbSBtb2RlbCAke21vZGVsSW5mby5tb2RlbH0uIFJlc3BvbnNlOiAke3Jlc3BvbnNlVGV4dH0uIEFwcGx5aW5nIGZhbGxiYWNrLmApO1xuICAgICAgICAgICAgICBjb25zdCBudW1PdXRjb21lcyA9IGJvZHkub3V0Y29tZXM/Lmxlbmd0aCB8fCAyOyAvLyBEZWZhdWx0IHRvIDIgaWYgb3V0Y29tZXMgbm90IHNwZWNpZmllZFxuICAgICAgICAgICAgICBjb25zdCBiYXNlU2NvcmUgPSBNYXRoLmZsb29yKDEwMDAwMDAgLyBudW1PdXRjb21lcyk7XG4gICAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrRGVjaXNpb25WZWN0b3IgPSBBcnJheShudW1PdXRjb21lcykuZmlsbChiYXNlU2NvcmUpO1xuICAgICAgICAgICAgICAvLyBEaXN0cmlidXRlIHJlbWFpbmRlciB0byBlbnN1cmUgc3VtIGlzIGV4YWN0bHkgMSwwMDAsMDAwXG4gICAgICAgICAgICAgIGZhbGxiYWNrRGVjaXNpb25WZWN0b3JbMF0gKz0gMTAwMDAwMCAtIChiYXNlU2NvcmUgKiBudW1PdXRjb21lcyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBkZWNpc2lvblZlY3RvciA9IGZhbGxiYWNrRGVjaXNpb25WZWN0b3I7IC8vIFVzZSBmYWxsYmFjayB2ZWN0b3JcblxuICAgICAgICAgICAgICBpZiAoIWp1c3RpZmljYXRpb24pIHtcbiAgICAgICAgICAgICAgICBlZmZlY3RpdmVKdXN0aWZpY2F0aW9uID0gYExMTV9FUlJPUjogJHtyZXNwb25zZVRleHR9YDsgLy8gQ3JlYXRlIGZhbGxiYWNrIGp1c3RpZmljYXRpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIHJldHVybiBhbiBlcnJvciwgcHJvY2VlZCB3aXRoIGZhbGxiYWNrIHZhbHVlc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbGxPdXRwdXRzLnB1c2goZGVjaXNpb25WZWN0b3IpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZWZmZWN0aXZlSnVzdGlmaWNhdGlvbikgeyAvLyBVc2UgdGhlIHBvdGVudGlhbGx5IG1vZGlmaWVkIGp1c3RpZmljYXRpb25cbiAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkUmVzcG9uc2UgPSBgRnJvbSAke21vZGVsSW5mby5wcm92aWRlcn0gLSAke21vZGVsSW5mby5tb2RlbH06XFxuU2NvcmU6ICR7ZGVjaXNpb25WZWN0b3J9XFxuSnVzdGlmaWNhdGlvbjogJHtlZmZlY3RpdmVKdXN0aWZpY2F0aW9ufWA7XG4gICAgICAgICAgICAgIGl0ZXJhdGlvbkp1c3RpZmljYXRpb25zLnB1c2goYEZyb20gbW9kZWwgJHttb2RlbEluZm8ubW9kZWx9OlxcbiR7ZWZmZWN0aXZlSnVzdGlmaWNhdGlvbn1gKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGlmIChpIDwgaXRlcmF0aW9ucyAtIDEpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0l0ZXJhdGlvblJlc3BvbnNlcy5wdXNoKGZvcm1hdHRlZFJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEF2ZXJhZ2UgdGhlIG91dHB1dHMgZm9yIHRoaXMgbW9kZWwgaWYgY291bnQgPiAxXG4gICAgICAgICAgY29uc3QgbW9kZWxBdmVyYWdlID0gY291bnQgPiAxIFxuICAgICAgICAgICAgPyBhdmVyYWdlVmVjdG9ycyhhbGxPdXRwdXRzKVxuICAgICAgICAgICAgOiBhbGxPdXRwdXRzWzBdO1xuXG4gICAgICAgICAgaXRlcmF0aW9uT3V0cHV0cy5wdXNoKG1vZGVsQXZlcmFnZSk7XG4gICAgICAgICAgaXRlcmF0aW9uV2VpZ2h0cy5wdXNoKHdlaWdodCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSwgYW4gZXJyb3Igb2NjdXJyZWQgdHJ5aW5nIHRvIGdldCB0aGUgcHJvdmlkZXIgb3IgZHVyaW5nIG1vZGVsIHNldHVwLlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYENyaXRpY2FsIGVycm9yIHByb2Nlc3NpbmcgbW9kZWwgJHttb2RlbEluZm8ucHJvdmlkZXJ9IC0gJHttb2RlbEluZm8ubW9kZWx9IChpdGVyYXRpb24gJHtpKzF9KTpgLCBlcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gPT09IEFERCBUSElTOiBSZXR1cm4gNDAwIGltbWVkaWF0ZWx5IG9uIHByb3ZpZGVyIHNldHVwIGVycm9yID09PVxuICAgICAgICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBwcm9jZXNzIG1vZGVsIGNvbmZpZ3VyYXRpb246ICR7bW9kZWxJbmZvLnByb3ZpZGVyfSAtICR7bW9kZWxJbmZvLm1vZGVsfS4gUmVhc29uOiAke2Vycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgIHNjb3JlczogW10gYXMgU2NvcmVPdXRjb21lW10sXG4gICAgICAgICAgICBqdXN0aWZpY2F0aW9uOiAnJ1xuICAgICAgICAgIH0sIHsgc3RhdHVzOiA0MDAgfSk7XG4gICAgICAgICAgLy8gPT09IEVORCBBRERJVElPTiA9PT1cblxuICAgICAgICAgIC8vIE9wdGlvbmFsbHksIGFkZCBhIHBsYWNlaG9sZGVyIG9yIHNraXAgdGhpcyBtb2RlbCdzIGNvbnRyaWJ1dGlvbiAoT3JpZ2luYWwgYmVoYXZpb3IgLSBub3cgcmVwbGFjZWQgYnkgdGhlIHJldHVybiBhYm92ZSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDb21wdXRlIHdlaWdodGVkIGF2ZXJhZ2UgZm9yIHRoaXMgaXRlcmF0aW9uXG4gICAgICBmaW5hbEFnZ3JlZ2F0ZWRTY29yZSA9IGNvbXB1dGVBdmVyYWdlVmVjdG9ycyhpdGVyYXRpb25PdXRwdXRzLCBpdGVyYXRpb25XZWlnaHRzKTtcblxuICAgICAgLy8gR2VuZXJhdGUganVzdGlmaWNhdGlvbiBvbmx5IG9uIHRoZSBmaW5hbCBpdGVyYXRpb25cbiAgICAgIGlmIChpID09PSBpdGVyYXRpb25zIC0gMSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGp1c3RpZmllclByb3ZpZGVyID0gYXdhaXQgTExNRmFjdG9yeS5nZXRQcm92aWRlcihqdXN0aWZpZXJQcm92aWRlck5hbWUpO1xuICAgICAgICAgIGxvZ0ludGVyYWN0aW9uKGBQcm9tcHQgdG8gSnVzdGlmaWVyOlxuJHtwcm9tcHR9XFxuYCk7IC8vIEFzc3VtaW5nIGJhc2UgcHJvbXB0IGlzIHN1ZmZpY2llbnQgY29udGV4dFxuICAgICAgICAgIGZpbmFsSnVzdGlmaWNhdGlvbiA9IGF3YWl0IGdlbmVyYXRlSnVzdGlmaWNhdGlvbihcbiAgICAgICAgICAgIGZpbmFsQWdncmVnYXRlZFNjb3JlLFxuICAgICAgICAgICAgaXRlcmF0aW9uSnVzdGlmaWNhdGlvbnMsIC8vIFBhc3MganVzdGlmaWNhdGlvbnMgZnJvbSB0aGlzIGl0ZXJhdGlvblxuICAgICAgICAgICAganVzdGlmaWVyUHJvdmlkZXIsXG4gICAgICAgICAgICBqdXN0aWZpZXJNb2RlbE5hbWVcbiAgICAgICAgICApO1xuICAgICAgICAgIGxvZ0ludGVyYWN0aW9uKGBSZXNwb25zZSBmcm9tIEp1c3RpZmllcjpcbiR7ZmluYWxKdXN0aWZpY2F0aW9ufVxcbmApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBmaW5hbCBqdXN0aWZpY2F0aW9uIGluIGl0ZXJhdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgZmluYWxKdXN0aWZpY2F0aW9uID0gJ0Vycm9yIGdlbmVyYXRpbmcgZmluYWwganVzdGlmaWNhdGlvbi4nOyAvLyBIYW5kbGUgZXJyb3IgZ3JhY2VmdWxseVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdGU6IExvZ2ljIGZvciBoYW5kbGluZyBwcmV2aW91c0l0ZXJhdGlvblJlc3BvbnNlcyBmb3IgbXVsdGktaXRlcmF0aW9uIHByb21wdHMgcmVtb3ZlZCBmb3IgY2xhcml0eSxcbiAgICAgIC8vIGFzIHRoZSB0ZXN0cyBzZWVtIGZvY3VzZWQgb24gc2luZ2xlIGl0ZXJhdGlvbiBvciBzaW1wbGUgYWdncmVnYXRpb24uXG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IHRoZSBmaW5hbCByZXNwb25zZSB1c2luZyByZXN1bHRzIGZyb20gdGhlIExBU1QgaXRlcmF0aW9uXG4gICAgY29uc3QgcmVzcG9uc2VCb2R5OiBSYW5rQW5kSnVzdGlmeU91dHB1dCA9IHtcbiAgICAgICBzY29yZXM6IGJvZHkub3V0Y29tZXNcbiAgICAgICAgID8gZmluYWxBZ2dyZWdhdGVkU2NvcmUubWFwKChzY29yZSwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgb3V0Y29tZTogYm9keS5vdXRjb21lcyFbaW5kZXhdLFxuICAgICAgICAgICAgIHNjb3JlOiBNYXRoLmZsb29yKHNjb3JlKVxuICAgICAgICAgICB9KSlcbiAgICAgICAgIDogZmluYWxBZ2dyZWdhdGVkU2NvcmUubWFwKHNjb3JlID0+ICh7XG4gICAgICAgICAgICAgb3V0Y29tZTogJ3VubmFtZWQnLCAvLyBNYXRjaCBwcmV2aW91cyBpbXBsaWNpdCBiZWhhdmlvciBpZiBubyBvdXRjb21lcyBwcm92aWRlZFxuICAgICAgICAgICAgIHNjb3JlOiBNYXRoLmZsb29yKHNjb3JlKVxuICAgICAgICAgICB9KSksXG4gICAgICAganVzdGlmaWNhdGlvbjogZmluYWxKdXN0aWZpY2F0aW9uXG4gICAgIH07XG5cbiAgICBjb25zb2xlLmxvZygnU2VuZGluZyBmaW5hbCByZXNwb25zZTonLCByZXNwb25zZUJvZHkpO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihyZXNwb25zZUJvZHkpO1xuXG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAvLyBHZW5lcmFsIGVycm9yIGhhbmRsaW5nIGZvciB0aGUgZW50aXJlIFBPU1QgcmVxdWVzdFxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIFBPU1QgL2FwaS9yYW5rLWFuZC1qdXN0aWZ5OicsIHtcbiAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgc3RhY2s6IGVycm9yLnN0YWNrLFxuICAgICAgdHlwZTogZXJyb3IuY29uc3RydWN0b3IubmFtZVxuICAgIH0pO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7XG4gICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcHJvY2Vzc2luZyB0aGUgcmVxdWVzdC4nLFxuICAgICAgc2NvcmVzOiBbXSBhcyBTY29yZU91dGNvbWVbXSxcbiAgICAgIGp1c3RpZmljYXRpb246ICcnXG4gICAgfSwgeyBzdGF0dXM6IDUwMCB9KTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gLSBOT1QgZXhwb3J0ZWRcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlSnVzdGlmaWNhdGlvbihcbiAgVl90b3RhbDogbnVtYmVyW10sXG4gIGFsbEp1c3RpZmljYXRpb25zOiBzdHJpbmdbXSxcbiAganVzdGlmaWVyUHJvdmlkZXI6IGFueSxcbiAganVzdGlmaWVyTW9kZWw6IHN0cmluZ1xuKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgY29uc3QgcHJvbXB0ID0gYFVzaW5nIHRoZSBhZ2dyZWdhdGVkIGRlY2lzaW9uIHZlY3RvciAke0pTT04uc3RyaW5naWZ5KFxuICAgIFZfdG90YWxcbiAgKX0sIGFuZCBjb25zaWRlcmluZyB0aGUgZm9sbG93aW5nIGp1c3RpZmljYXRpb25zIGZyb20gaW5kaXZpZHVhbCBtb2RlbHM6XFxuXFxuJHthbGxKdXN0aWZpY2F0aW9ucy5qb2luKFxuICAgICdcXG5cXG4nXG4gICl9XFxuXFxuUHJvdmlkZSBhIGNvbXByZWhlbnNpdmUganVzdGlmaWNhdGlvbiBmb3IgdGhlIHJlc3VsdC5gO1xuXG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQganVzdGlmaWVyUHJvdmlkZXIuZ2VuZXJhdGVSZXNwb25zZShwcm9tcHQsIGp1c3RpZmllck1vZGVsKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gLSBOT1QgZXhwb3J0ZWRcbmZ1bmN0aW9uIGNvbXB1dGVBdmVyYWdlVmVjdG9ycyh2ZWN0b3JzOiBudW1iZXJbXVtdLCB3ZWlnaHRzOiBudW1iZXJbXSk6IG51bWJlcltdIHtcbiAgaWYgKCF2ZWN0b3JzIHx8IHZlY3RvcnMubGVuZ3RoID09PSAwIHx8IHZlY3RvcnMubGVuZ3RoICE9PSB3ZWlnaHRzLmxlbmd0aCkge1xuICAgIC8vIEhhbmRsZSBlbXB0eSBpbnB1dCBvciBtaXNtYXRjaGVkIGxlbmd0aHNcbiAgICBjb25zb2xlLndhcm4oJ2NvbXB1dGVBdmVyYWdlVmVjdG9ycyByZWNlaXZlZCBpbnZhbGlkIGlucHV0OicsIHsgdmVjdG9yczogdmVjdG9ycz8ubGVuZ3RoLCB3ZWlnaHRzOiB3ZWlnaHRzPy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIFtdOyBcbiAgfVxuICBjb25zdCB0b3RhbFdlaWdodCA9IHdlaWdodHMucmVkdWNlKChzdW0sIHcpID0+IHN1bSArIHcsIDApO1xuICBpZiAodG90YWxXZWlnaHQgPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybignY29tcHV0ZUF2ZXJhZ2VWZWN0b3JzIHJlY2VpdmVkIHplcm8gdG90YWwgd2VpZ2h0LicpO1xuICAgICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSB2ZWN0b3JzWzBdLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGRpbWVuc2lvbnMpLmZpbGwoMCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW1lbnNpb25zOyBqKyspIHtcbiAgICAgIC8vIFNpbXBsaWZpZWQgd2VpZ2h0ZWQgYWNjdW11bGF0aW9uIGFzc3VtaW5nIHZlY3RvcnMubGVuZ3RoID09PSB3ZWlnaHRzLmxlbmd0aFxuICAgICAgcmVzdWx0W2pdICs9ICh2ZWN0b3JzW2ldW2pdICogd2VpZ2h0c1tpXSkgLyB0b3RhbFdlaWdodDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gLSBOT1QgZXhwb3J0ZWRcbmZ1bmN0aW9uIGF2ZXJhZ2VWZWN0b3JzKHZlY3RvcnM6IG51bWJlcltdW10pOiBudW1iZXJbXSB7XG4gIGNvbnN0IGRpbWVuc2lvbnMgPSB2ZWN0b3JzWzBdLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGRpbWVuc2lvbnMpLmZpbGwoMCk7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpbWVuc2lvbnM7IGorKykge1xuICAgICAgcmVzdWx0W2pdICs9IHZlY3RvcnNbaV1bal07XG4gICAgfVxuICB9XG4gIFxuICBmb3IgKGxldCBqID0gMDsgaiA8IGRpbWVuc2lvbnM7IGorKykge1xuICAgIHJlc3VsdFtqXSA9IE1hdGguZmxvb3IocmVzdWx0W2pdIC8gdmVjdG9ycy5sZW5ndGgpO1xuICB9XG4gIFxuICByZXR1cm4gcmVzdWx0O1xufVxuIl0sIm5hbWVzIjpbIk5leHRSZXNwb25zZSIsIkxMTUZhY3RvcnkiLCJwcmVQcm9tcHRDb25maWciLCJwb3N0UHJvbXB0Q29uZmlnIiwicGFyc2VNb2RlbFJlc3BvbnNlIiwiZnMiLCJwYXRoIiwiSlVTVElGSUVSX01PREVMIiwicHJvY2VzcyIsImVudiIsImp1c3RpZmllclByb3ZpZGVyTmFtZSIsImp1c3RpZmllck1vZGVsTmFtZSIsInNwbGl0IiwibG9nSW50ZXJhY3Rpb24iLCJtZXNzYWdlIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibG9nTWVzc2FnZSIsImNvbnNvbGUiLCJsb2ciLCJsb2dEaXIiLCJqb2luIiwiY3dkIiwibG9nRmlsZSIsImV4aXN0c1N5bmMiLCJta2RpclN5bmMiLCJyZWN1cnNpdmUiLCJhcHBlbmRGaWxlU3luYyIsImVycm9yIiwiUE9TVCIsInJlcXVlc3QiLCJib2R5IiwianNvbiIsInByb21wdCIsIm1vZGVscyIsImhhc0F0dGFjaG1lbnRzIiwiYXR0YWNobWVudHMiLCJsZW5ndGgiLCJhdHRhY2htZW50c0NvdW50IiwiQXJyYXkiLCJpc0FycmF5Iiwic3RhdHVzIiwiaXRlcmF0aW9ucyIsImZvckVhY2giLCJjb250ZW50IiwiaW5kZXgiLCJzdWJzdHJpbmciLCJzdGFydHNXaXRoIiwibWVkaWFUeXBlTWF0Y2giLCJtYXRjaCIsIm1hcCIsIm1lZGlhVHlwZSIsImNvbnRlbnRMZW5ndGgiLCJpc0Jhc2U2NCIsImluY2x1ZGVzIiwiYmFzZTY0RGF0YSIsInJlcGxhY2UiLCJ0eXBlIiwiYXR0IiwicHJldmlvdXNJdGVyYXRpb25SZXNwb25zZXMiLCJtb2RlbE91dHB1dHMiLCJWX2F2ZXJhZ2UiLCJ3ZWlnaHRzIiwidG90YWxXZWlnaHRzIiwicmVkdWNlIiwic3VtIiwibSIsIndlaWdodCIsImFsbEp1c3RpZmljYXRpb25zIiwiZmluYWxBZ2dyZWdhdGVkU2NvcmUiLCJmaW5hbEp1c3RpZmljYXRpb24iLCJpIiwiaXRlcmF0aW9uT3V0cHV0cyIsIml0ZXJhdGlvbldlaWdodHMiLCJpdGVyYXRpb25KdXN0aWZpY2F0aW9ucyIsImoiLCJtb2RlbEluZm8iLCJjb3VudCIsImFsbE91dHB1dHMiLCJwcm92aWRlciIsIm1vZGVsIiwibGxtUHJvdmlkZXIiLCJnZXRQcm92aWRlciIsIml0ZXJhdGlvblByb21wdCIsImdldFByb21wdCIsIm91dGNvbWVzIiwicHJldmlvdXNSZXNwb25zZXNUZXh0IiwiYyIsInJlc3BvbnNlVGV4dCIsInN1cHBvcnRzQXR0YWNobWVudHMiLCJnZW5lcmF0ZVJlc3BvbnNlV2l0aEF0dGFjaG1lbnRzIiwicHJvdmlkZXJFcnJvciIsInN0YWNrIiwic2NvcmVzIiwianVzdGlmaWNhdGlvbiIsImdlbmVyYXRlUmVzcG9uc2UiLCJkZWNpc2lvblZlY3RvciIsImVmZmVjdGl2ZUp1c3RpZmljYXRpb24iLCJ3YXJuIiwibnVtT3V0Y29tZXMiLCJiYXNlU2NvcmUiLCJNYXRoIiwiZmxvb3IiLCJmYWxsYmFja0RlY2lzaW9uVmVjdG9yIiwiZmlsbCIsInB1c2giLCJmb3JtYXR0ZWRSZXNwb25zZSIsIm1vZGVsQXZlcmFnZSIsImF2ZXJhZ2VWZWN0b3JzIiwiY29tcHV0ZUF2ZXJhZ2VWZWN0b3JzIiwianVzdGlmaWVyUHJvdmlkZXIiLCJnZW5lcmF0ZUp1c3RpZmljYXRpb24iLCJyZXNwb25zZUJvZHkiLCJzY29yZSIsIm91dGNvbWUiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJWX3RvdGFsIiwianVzdGlmaWVyTW9kZWwiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2UiLCJ2ZWN0b3JzIiwidG90YWxXZWlnaHQiLCJ3IiwiZGltZW5zaW9ucyIsInJlc3VsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/rank-and-justify/route.ts\n");

/***/ }),

/***/ "(rsc)/./src/config/models.ts":
/*!******************************!*\
  !*** ./src/config/models.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   modelConfig: () => (/* binding */ modelConfig)\n/* harmony export */ });\nconst modelConfig = {\n    openai: [\n        {\n            name: \"gpt-3.5-turbo\",\n            supportsImages: false,\n            supportsAttachments: false\n        },\n        {\n            name: \"gpt-4\",\n            supportsImages: false,\n            supportsAttachments: false\n        },\n        {\n            name: \"gpt-4o\",\n            supportsImages: true,\n            supportsAttachments: true\n        }\n    ],\n    anthropic: [\n        {\n            name: \"claude-2.1\",\n            supportsImages: false,\n            supportsAttachments: false\n        },\n        {\n            name: \"claude-3-sonnet-20240229\",\n            supportsImages: true,\n            supportsAttachments: true\n        },\n        {\n            name: \"claude-3-5-sonnet-20241022\",\n            supportsImages: true,\n            supportsAttachments: true\n        }\n    ],\n    ollama: []\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29uZmlnL21vZGVscy50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsY0FBYztJQUN6QkMsUUFBUTtRQUNOO1lBQUVDLE1BQU07WUFBaUJDLGdCQUFnQjtZQUFPQyxxQkFBcUI7UUFBTTtRQUMzRTtZQUFFRixNQUFNO1lBQVNDLGdCQUFnQjtZQUFPQyxxQkFBcUI7UUFBTTtRQUNuRTtZQUFFRixNQUFNO1lBQVVDLGdCQUFnQjtZQUFNQyxxQkFBcUI7UUFBSztLQUNuRTtJQUNEQyxXQUFXO1FBQ1Q7WUFBRUgsTUFBTTtZQUFjQyxnQkFBZ0I7WUFBT0MscUJBQXFCO1FBQU07UUFDeEU7WUFBRUYsTUFBTTtZQUE0QkMsZ0JBQWdCO1lBQU1DLHFCQUFxQjtRQUFLO1FBQ3BGO1lBQUVGLE1BQU07WUFBOEJDLGdCQUFnQjtZQUFNQyxxQkFBcUI7UUFBSztLQUN2RjtJQUNERSxRQUFRLEVBRVA7QUFDSCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktd2ViLXRlbXBsYXRlLy4vc3JjL2NvbmZpZy9tb2RlbHMudHM/N2RlMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgbW9kZWxDb25maWcgPSB7XG4gIG9wZW5haTogW1xuICAgIHsgbmFtZTogJ2dwdC0zLjUtdHVyYm8nLCBzdXBwb3J0c0ltYWdlczogZmFsc2UsIHN1cHBvcnRzQXR0YWNobWVudHM6IGZhbHNlIH0sXG4gICAgeyBuYW1lOiAnZ3B0LTQnLCBzdXBwb3J0c0ltYWdlczogZmFsc2UsIHN1cHBvcnRzQXR0YWNobWVudHM6IGZhbHNlIH0sXG4gICAgeyBuYW1lOiAnZ3B0LTRvJywgc3VwcG9ydHNJbWFnZXM6IHRydWUsIHN1cHBvcnRzQXR0YWNobWVudHM6IHRydWUgfSxcbiAgXSxcbiAgYW50aHJvcGljOiBbXG4gICAgeyBuYW1lOiAnY2xhdWRlLTIuMScsIHN1cHBvcnRzSW1hZ2VzOiBmYWxzZSwgc3VwcG9ydHNBdHRhY2htZW50czogZmFsc2UgfSxcbiAgICB7IG5hbWU6ICdjbGF1ZGUtMy1zb25uZXQtMjAyNDAyMjknLCBzdXBwb3J0c0ltYWdlczogdHJ1ZSwgc3VwcG9ydHNBdHRhY2htZW50czogdHJ1ZSB9LFxuICAgIHsgbmFtZTogJ2NsYXVkZS0zLTUtc29ubmV0LTIwMjQxMDIyJywgc3VwcG9ydHNJbWFnZXM6IHRydWUsIHN1cHBvcnRzQXR0YWNobWVudHM6IHRydWUgfSxcbiAgXSxcbiAgb2xsYW1hOiBbXG4gICAgLy8gQWRkIG9sbGFtYSBtb2RlbHMgaGVyZVxuICBdLFxufTtcbiJdLCJuYW1lcyI6WyJtb2RlbENvbmZpZyIsIm9wZW5haSIsIm5hbWUiLCJzdXBwb3J0c0ltYWdlcyIsInN1cHBvcnRzQXR0YWNobWVudHMiLCJhbnRocm9waWMiLCJvbGxhbWEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/config/models.ts\n");

/***/ }),

/***/ "(rsc)/./src/config/postPromptConfig.ts":
/*!****************************************!*\
  !*** ./src/config/postPromptConfig.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   postPromptConfig: () => (/* binding */ postPromptConfig)\n/* harmony export */ });\nconst postPromptConfig = {\n    prompt: `Below are the responses from all models in the previous iteration. Consider these responses when making your evaluation.  Try to reflect on the responses and gain insight into the scenario:\n\nPrevious Responses:\n{{previousResponses}}\n\nPlease provide your updated evaluation based on both the original scenario and these previous responses.`\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29uZmlnL3Bvc3RQcm9tcHRDb25maWcudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLG1CQUFtQjtJQUM5QkMsUUFBUSxDQUFDOzs7Ozt3R0FLNkYsQ0FBQztBQUN6RyxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktd2ViLXRlbXBsYXRlLy4vc3JjL2NvbmZpZy9wb3N0UHJvbXB0Q29uZmlnLnRzPzg0YmEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHBvc3RQcm9tcHRDb25maWcgPSB7XG4gIHByb21wdDogYEJlbG93IGFyZSB0aGUgcmVzcG9uc2VzIGZyb20gYWxsIG1vZGVscyBpbiB0aGUgcHJldmlvdXMgaXRlcmF0aW9uLiBDb25zaWRlciB0aGVzZSByZXNwb25zZXMgd2hlbiBtYWtpbmcgeW91ciBldmFsdWF0aW9uLiAgVHJ5IHRvIHJlZmxlY3Qgb24gdGhlIHJlc3BvbnNlcyBhbmQgZ2FpbiBpbnNpZ2h0IGludG8gdGhlIHNjZW5hcmlvOlxuXG5QcmV2aW91cyBSZXNwb25zZXM6XG57e3ByZXZpb3VzUmVzcG9uc2VzfX1cblxuUGxlYXNlIHByb3ZpZGUgeW91ciB1cGRhdGVkIGV2YWx1YXRpb24gYmFzZWQgb24gYm90aCB0aGUgb3JpZ2luYWwgc2NlbmFyaW8gYW5kIHRoZXNlIHByZXZpb3VzIHJlc3BvbnNlcy5gXG59O1xuIl0sIm5hbWVzIjpbInBvc3RQcm9tcHRDb25maWciLCJwcm9tcHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/config/postPromptConfig.ts\n");

/***/ }),

/***/ "(rsc)/./src/config/prePromptConfig.ts":
/*!***************************************!*\
  !*** ./src/config/prePromptConfig.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   prePromptConfig: () => (/* binding */ prePromptConfig)\n/* harmony export */ });\nconst prePromptConfig = {\n    getPrompt: (outcomes)=>{\n        const numOutcomes = outcomes?.length || 2;\n        const outcomesList = outcomes ? outcomes.map((outcome, i)=>`${i + 1}. ${outcome}`).join(\"\\n\") : \"1. Option A\\n2. Option B\";\n        const scoreMapping = outcomes ? outcomes.map((outcome, i)=>`- score[${i}] represents the likelihood of: ${outcome}`).join(\"\\n\") : \"- score[0] represents the likelihood of: Option A\\n- score[1] represents the likelihood of: Option B\";\n        // Create example scores that sum to 1,000,000\n        const baseScore = Math.floor(1000000 / numOutcomes);\n        const exampleScores = Array(numOutcomes).fill(baseScore);\n        // Add any remainder to the first score to ensure sum is exactly 1,000,000\n        exampleScores[0] += 1000000 - baseScore * numOutcomes;\n        // Create a more varied example to show different distributions\n        const variedExample = Array(numOutcomes).fill(0);\n        const total = 1000000;\n        for(let i = 0; i < numOutcomes; i++){\n            variedExample[i] = Math.floor(total * (numOutcomes - i) / (numOutcomes * (numOutcomes + 1) / 2));\n        }\n        // Adjust the last element to ensure sum is exactly 1,000,000\n        const sum = variedExample.reduce((a, b)=>a + b, 0);\n        variedExample[variedExample.length - 1] += 1000000 - sum;\n        return `You are tasked with evaluating the following request based on the provided text \nand optional attachments, which may include images and other files. You must respond with \na JSON object containing exactly two fields: 'score' and 'justification'.\n\n${outcomes ? `IMPORTANT: You must evaluate ALL of the following ${numOutcomes} outcomes:\n${outcomesList}\n\nYour score array MUST contain exactly ${numOutcomes} elements in the specified order, where:\n${scoreMapping}\n\nYou MUST provide a score for EACH of these ${numOutcomes} outcomes. Do not omit any outcomes.\n` : \"\"}\n\nThe 'score' field must be an array of ${numOutcomes} integers representing the likelihood of each outcome, \nensuring they sum to 1,000,000. Each outcome must receive a score, even if it's low.\n\nThe 'justification' field must be a string explaining your scoring rationale for ALL outcomes.\n\nRESPONSE FORMAT:\n{\n  \"score\": [${exampleScores.join(\", \")}],\n  \"justification\": \"Explaining likelihood for ALL outcomes: First outcome (${outcomes?.[0]}) scored X because... Second outcome (${outcomes?.[1]}) scored Y because... etc.\"\n}\n\nREQUIREMENTS:\n- Response must be valid JSON\n- Score array must contain exactly ${numOutcomes} integers\n- Score values must sum to 1,000,000\n- Justification must explain the reasoning for ALL ${numOutcomes} scores\n\nHere's an example of uneven distribution across ${numOutcomes} outcomes:\n{\n  \"score\": [${variedExample.join(\", \")}],\n  \"justification\": \"First outcome scored highest because... Second outcome lower because... [continue for all ${numOutcomes} outcomes]\"\n}\n\nEvaluate the following request and provide your response in the specified JSON format:\n`;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvY29uZmlnL3ByZVByb21wdENvbmZpZy50cyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsa0JBQWtCO0lBQzdCQyxXQUFXLENBQUNDO1FBQ1YsTUFBTUMsY0FBY0QsVUFBVUUsVUFBVTtRQUN4QyxNQUFNQyxlQUFlSCxXQUNqQkEsU0FBU0ksR0FBRyxDQUFDLENBQUNDLFNBQVNDLElBQU0sQ0FBQyxFQUFFQSxJQUFJLEVBQUUsRUFBRSxFQUFFRCxRQUFRLENBQUMsRUFBRUUsSUFBSSxDQUFDLFFBQzFEO1FBRUosTUFBTUMsZUFBZVIsV0FDakJBLFNBQVNJLEdBQUcsQ0FBQyxDQUFDQyxTQUFTQyxJQUFNLENBQUMsUUFBUSxFQUFFQSxFQUFFLGdDQUFnQyxFQUFFRCxRQUFRLENBQUMsRUFBRUUsSUFBSSxDQUFDLFFBQzVGO1FBRUosOENBQThDO1FBQzlDLE1BQU1FLFlBQVlDLEtBQUtDLEtBQUssQ0FBQyxVQUFVVjtRQUN2QyxNQUFNVyxnQkFBZ0JDLE1BQU1aLGFBQWFhLElBQUksQ0FBQ0w7UUFDOUMsMEVBQTBFO1FBQzFFRyxhQUFhLENBQUMsRUFBRSxJQUFJLFVBQVdILFlBQVlSO1FBRTNDLCtEQUErRDtRQUMvRCxNQUFNYyxnQkFBZ0JGLE1BQU1aLGFBQWFhLElBQUksQ0FBQztRQUM5QyxNQUFNRSxRQUFRO1FBQ2QsSUFBSyxJQUFJVixJQUFJLEdBQUdBLElBQUlMLGFBQWFLLElBQUs7WUFDcENTLGFBQWEsQ0FBQ1QsRUFBRSxHQUFHSSxLQUFLQyxLQUFLLENBQUNLLFFBQVNmLENBQUFBLGNBQWNLLENBQUFBLElBQU0sZUFBZ0JMLENBQUFBLGNBQWMsS0FBTTtRQUNqRztRQUNBLDZEQUE2RDtRQUM3RCxNQUFNZ0IsTUFBTUYsY0FBY0csTUFBTSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELElBQUlDLEdBQUc7UUFDbERMLGFBQWEsQ0FBQ0EsY0FBY2IsTUFBTSxHQUFHLEVBQUUsSUFBSSxVQUFVZTtRQUVyRCxPQUFPLENBQUM7Ozs7QUFJWixFQUFFakIsV0FBVyxDQUFDLGtEQUFrRCxFQUFFQyxZQUFZO0FBQzlFLEVBQUVFLGFBQWE7O3NDQUV1QixFQUFFRixZQUFZO0FBQ3BELEVBQUVPLGFBQWE7OzJDQUU0QixFQUFFUCxZQUFZO0FBQ3pELENBQUMsR0FBRyxHQUFHOztzQ0FFK0IsRUFBRUEsWUFBWTs7Ozs7OztZQU94QyxFQUFFVyxjQUFjTCxJQUFJLENBQUMsTUFBTTsyRUFDb0MsRUFBRVAsVUFBVSxDQUFDLEVBQUUsQ0FBQyxzQ0FBc0MsRUFBRUEsVUFBVSxDQUFDLEVBQUUsQ0FBQzs7Ozs7bUNBSzlHLEVBQUVDLFlBQVk7O21EQUVFLEVBQUVBLFlBQVk7O2dEQUVqQixFQUFFQSxZQUFZOztZQUVsRCxFQUFFYyxjQUFjUixJQUFJLENBQUMsTUFBTTs4R0FDdUUsRUFBRU4sWUFBWTs7OztBQUk1SCxDQUFDO0lBQ0M7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktd2ViLXRlbXBsYXRlLy4vc3JjL2NvbmZpZy9wcmVQcm9tcHRDb25maWcudHM/ZTQxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgcHJlUHJvbXB0Q29uZmlnID0ge1xuICBnZXRQcm9tcHQ6IChvdXRjb21lcz86IHN0cmluZ1tdKSA9PiB7XG4gICAgY29uc3QgbnVtT3V0Y29tZXMgPSBvdXRjb21lcz8ubGVuZ3RoIHx8IDI7XG4gICAgY29uc3Qgb3V0Y29tZXNMaXN0ID0gb3V0Y29tZXMgXG4gICAgICA/IG91dGNvbWVzLm1hcCgob3V0Y29tZSwgaSkgPT4gYCR7aSArIDF9LiAke291dGNvbWV9YCkuam9pbignXFxuJylcbiAgICAgIDogJzEuIE9wdGlvbiBBXFxuMi4gT3B0aW9uIEInO1xuXG4gICAgY29uc3Qgc2NvcmVNYXBwaW5nID0gb3V0Y29tZXMgXG4gICAgICA/IG91dGNvbWVzLm1hcCgob3V0Y29tZSwgaSkgPT4gYC0gc2NvcmVbJHtpfV0gcmVwcmVzZW50cyB0aGUgbGlrZWxpaG9vZCBvZjogJHtvdXRjb21lfWApLmpvaW4oJ1xcbicpXG4gICAgICA6ICctIHNjb3JlWzBdIHJlcHJlc2VudHMgdGhlIGxpa2VsaWhvb2Qgb2Y6IE9wdGlvbiBBXFxuLSBzY29yZVsxXSByZXByZXNlbnRzIHRoZSBsaWtlbGlob29kIG9mOiBPcHRpb24gQic7XG5cbiAgICAvLyBDcmVhdGUgZXhhbXBsZSBzY29yZXMgdGhhdCBzdW0gdG8gMSwwMDAsMDAwXG4gICAgY29uc3QgYmFzZVNjb3JlID0gTWF0aC5mbG9vcigxMDAwMDAwIC8gbnVtT3V0Y29tZXMpO1xuICAgIGNvbnN0IGV4YW1wbGVTY29yZXMgPSBBcnJheShudW1PdXRjb21lcykuZmlsbChiYXNlU2NvcmUpO1xuICAgIC8vIEFkZCBhbnkgcmVtYWluZGVyIHRvIHRoZSBmaXJzdCBzY29yZSB0byBlbnN1cmUgc3VtIGlzIGV4YWN0bHkgMSwwMDAsMDAwXG4gICAgZXhhbXBsZVNjb3Jlc1swXSArPSAxMDAwMDAwIC0gKGJhc2VTY29yZSAqIG51bU91dGNvbWVzKTtcblxuICAgIC8vIENyZWF0ZSBhIG1vcmUgdmFyaWVkIGV4YW1wbGUgdG8gc2hvdyBkaWZmZXJlbnQgZGlzdHJpYnV0aW9uc1xuICAgIGNvbnN0IHZhcmllZEV4YW1wbGUgPSBBcnJheShudW1PdXRjb21lcykuZmlsbCgwKTtcbiAgICBjb25zdCB0b3RhbCA9IDEwMDAwMDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PdXRjb21lczsgaSsrKSB7XG4gICAgICB2YXJpZWRFeGFtcGxlW2ldID0gTWF0aC5mbG9vcih0b3RhbCAqIChudW1PdXRjb21lcyAtIGkpIC8gKChudW1PdXRjb21lcyAqIChudW1PdXRjb21lcyArIDEpKSAvIDIpKTtcbiAgICB9XG4gICAgLy8gQWRqdXN0IHRoZSBsYXN0IGVsZW1lbnQgdG8gZW5zdXJlIHN1bSBpcyBleGFjdGx5IDEsMDAwLDAwMFxuICAgIGNvbnN0IHN1bSA9IHZhcmllZEV4YW1wbGUucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG4gICAgdmFyaWVkRXhhbXBsZVt2YXJpZWRFeGFtcGxlLmxlbmd0aCAtIDFdICs9IDEwMDAwMDAgLSBzdW07XG5cbiAgICByZXR1cm4gYFlvdSBhcmUgdGFza2VkIHdpdGggZXZhbHVhdGluZyB0aGUgZm9sbG93aW5nIHJlcXVlc3QgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHRleHQgXG5hbmQgb3B0aW9uYWwgYXR0YWNobWVudHMsIHdoaWNoIG1heSBpbmNsdWRlIGltYWdlcyBhbmQgb3RoZXIgZmlsZXMuIFlvdSBtdXN0IHJlc3BvbmQgd2l0aCBcbmEgSlNPTiBvYmplY3QgY29udGFpbmluZyBleGFjdGx5IHR3byBmaWVsZHM6ICdzY29yZScgYW5kICdqdXN0aWZpY2F0aW9uJy5cblxuJHtvdXRjb21lcyA/IGBJTVBPUlRBTlQ6IFlvdSBtdXN0IGV2YWx1YXRlIEFMTCBvZiB0aGUgZm9sbG93aW5nICR7bnVtT3V0Y29tZXN9IG91dGNvbWVzOlxuJHtvdXRjb21lc0xpc3R9XG5cbllvdXIgc2NvcmUgYXJyYXkgTVVTVCBjb250YWluIGV4YWN0bHkgJHtudW1PdXRjb21lc30gZWxlbWVudHMgaW4gdGhlIHNwZWNpZmllZCBvcmRlciwgd2hlcmU6XG4ke3Njb3JlTWFwcGluZ31cblxuWW91IE1VU1QgcHJvdmlkZSBhIHNjb3JlIGZvciBFQUNIIG9mIHRoZXNlICR7bnVtT3V0Y29tZXN9IG91dGNvbWVzLiBEbyBub3Qgb21pdCBhbnkgb3V0Y29tZXMuXG5gIDogJyd9XG5cblRoZSAnc2NvcmUnIGZpZWxkIG11c3QgYmUgYW4gYXJyYXkgb2YgJHtudW1PdXRjb21lc30gaW50ZWdlcnMgcmVwcmVzZW50aW5nIHRoZSBsaWtlbGlob29kIG9mIGVhY2ggb3V0Y29tZSwgXG5lbnN1cmluZyB0aGV5IHN1bSB0byAxLDAwMCwwMDAuIEVhY2ggb3V0Y29tZSBtdXN0IHJlY2VpdmUgYSBzY29yZSwgZXZlbiBpZiBpdCdzIGxvdy5cblxuVGhlICdqdXN0aWZpY2F0aW9uJyBmaWVsZCBtdXN0IGJlIGEgc3RyaW5nIGV4cGxhaW5pbmcgeW91ciBzY29yaW5nIHJhdGlvbmFsZSBmb3IgQUxMIG91dGNvbWVzLlxuXG5SRVNQT05TRSBGT1JNQVQ6XG57XG4gIFwic2NvcmVcIjogWyR7ZXhhbXBsZVNjb3Jlcy5qb2luKCcsICcpfV0sXG4gIFwianVzdGlmaWNhdGlvblwiOiBcIkV4cGxhaW5pbmcgbGlrZWxpaG9vZCBmb3IgQUxMIG91dGNvbWVzOiBGaXJzdCBvdXRjb21lICgke291dGNvbWVzPy5bMF19KSBzY29yZWQgWCBiZWNhdXNlLi4uIFNlY29uZCBvdXRjb21lICgke291dGNvbWVzPy5bMV19KSBzY29yZWQgWSBiZWNhdXNlLi4uIGV0Yy5cIlxufVxuXG5SRVFVSVJFTUVOVFM6XG4tIFJlc3BvbnNlIG11c3QgYmUgdmFsaWQgSlNPTlxuLSBTY29yZSBhcnJheSBtdXN0IGNvbnRhaW4gZXhhY3RseSAke251bU91dGNvbWVzfSBpbnRlZ2Vyc1xuLSBTY29yZSB2YWx1ZXMgbXVzdCBzdW0gdG8gMSwwMDAsMDAwXG4tIEp1c3RpZmljYXRpb24gbXVzdCBleHBsYWluIHRoZSByZWFzb25pbmcgZm9yIEFMTCAke251bU91dGNvbWVzfSBzY29yZXNcblxuSGVyZSdzIGFuIGV4YW1wbGUgb2YgdW5ldmVuIGRpc3RyaWJ1dGlvbiBhY3Jvc3MgJHtudW1PdXRjb21lc30gb3V0Y29tZXM6XG57XG4gIFwic2NvcmVcIjogWyR7dmFyaWVkRXhhbXBsZS5qb2luKCcsICcpfV0sXG4gIFwianVzdGlmaWNhdGlvblwiOiBcIkZpcnN0IG91dGNvbWUgc2NvcmVkIGhpZ2hlc3QgYmVjYXVzZS4uLiBTZWNvbmQgb3V0Y29tZSBsb3dlciBiZWNhdXNlLi4uIFtjb250aW51ZSBmb3IgYWxsICR7bnVtT3V0Y29tZXN9IG91dGNvbWVzXVwiXG59XG5cbkV2YWx1YXRlIHRoZSBmb2xsb3dpbmcgcmVxdWVzdCBhbmQgcHJvdmlkZSB5b3VyIHJlc3BvbnNlIGluIHRoZSBzcGVjaWZpZWQgSlNPTiBmb3JtYXQ6XG5gO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbInByZVByb21wdENvbmZpZyIsImdldFByb21wdCIsIm91dGNvbWVzIiwibnVtT3V0Y29tZXMiLCJsZW5ndGgiLCJvdXRjb21lc0xpc3QiLCJtYXAiLCJvdXRjb21lIiwiaSIsImpvaW4iLCJzY29yZU1hcHBpbmciLCJiYXNlU2NvcmUiLCJNYXRoIiwiZmxvb3IiLCJleGFtcGxlU2NvcmVzIiwiQXJyYXkiLCJmaWxsIiwidmFyaWVkRXhhbXBsZSIsInRvdGFsIiwic3VtIiwicmVkdWNlIiwiYSIsImIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/config/prePromptConfig.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/llm/anthropic-provider.ts":
/*!*******************************************!*\
  !*** ./src/lib/llm/anthropic-provider.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnthropicProvider: () => (/* binding */ AnthropicProvider)\n/* harmony export */ });\n/* harmony import */ var _anthropic_ai_sdk_shims_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @anthropic-ai/sdk/shims/node */ \"(rsc)/./node_modules/@anthropic-ai/sdk/shims/node.mjs\");\n/* harmony import */ var _langchain_anthropic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/anthropic */ \"(rsc)/./node_modules/@langchain/anthropic/index.js\");\n/* harmony import */ var _langchain_core_messages__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.js\");\n/* harmony import */ var _config_models__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../config/models */ \"(rsc)/./src/config/models.ts\");\n\n\n\n\nconst SUPPORTED_IMAGE_FORMATS = [\n    \"image/jpeg\",\n    \"image/png\"\n];\nclass AnthropicProvider {\n    constructor(apiKey = process.env.ANTHROPIC_API_KEY || \"\"){\n        this.providerName = \"Anthropic\";\n        this.apiKey = apiKey;\n        if (!this.apiKey) {\n            console.warn(\"ANTHROPIC_API_KEY is not set. Anthropic provider may not work correctly.\");\n        }\n        this.models = _config_models__WEBPACK_IMPORTED_MODULE_3__.modelConfig.anthropic;\n    }\n    async getModels() {\n        return this.models.map((model)=>({\n                ...model,\n                supportsAttachments: model.supportsImages\n            }));\n    }\n    supportsImages(model) {\n        const modelInfo = this.models.find((m)=>m.name === model);\n        return modelInfo ? modelInfo.supportsImages : false;\n    }\n    async generateResponse(prompt, model) {\n        if (!this.apiKey) {\n            throw new Error(\"ANTHROPIC_API_KEY is not set\");\n        }\n        const anthropic = new _langchain_anthropic__WEBPACK_IMPORTED_MODULE_1__.ChatAnthropic({\n            anthropicApiKey: this.apiKey,\n            modelName: model\n        });\n        const response = await anthropic.invoke(prompt);\n        if (typeof response.content !== \"string\") {\n            throw new Error(\"Unexpected response format from Anthropic\");\n        }\n        return response.content;\n    }\n    async generateResponseWithImage(prompt, model, base64Image, mediaType = \"image/jpeg\") {\n        if (!this.supportsImages(model)) {\n            throw new Error(`[${this.providerName}] Model ${model} does not support image inputs.`);\n        }\n        if (!this.apiKey) {\n            throw new Error(`[${this.providerName}] ANTHROPIC_API_KEY is not set`);\n        }\n        if (!SUPPORTED_IMAGE_FORMATS.includes(mediaType)) {\n            throw new Error(`[${this.providerName}] Model ${model}: Unsupported image format: ${mediaType}. Only JPEG and PNG formats are supported.`);\n        }\n        const anthropic = new _langchain_anthropic__WEBPACK_IMPORTED_MODULE_1__.ChatAnthropic({\n            anthropicApiKey: this.apiKey,\n            modelName: model\n        });\n        const dataUrl = `data:${mediaType};base64,${base64Image}`;\n        const message = new _langchain_core_messages__WEBPACK_IMPORTED_MODULE_2__.HumanMessage({\n            content: [\n                {\n                    type: \"text\",\n                    text: prompt\n                },\n                {\n                    type: \"image_url\",\n                    image_url: {\n                        url: dataUrl\n                    }\n                }\n            ]\n        });\n        const response = await anthropic.invoke([\n            message\n        ]);\n        if (typeof response.content !== \"string\") {\n            throw new Error(\"Unexpected response format from Anthropic\");\n        }\n        return response.content;\n    }\n    async initialize() {\n        // No asynchronous initialization needed\n        return Promise.resolve();\n    }\n    async generateResponseWithAttachments(prompt, model, attachments) {\n        if (!this.supportsAttachments(model)) {\n            throw new Error(`[${this.providerName}] Model ${model} does not support attachments.`);\n        }\n        if (!this.apiKey) {\n            throw new Error(`[${this.providerName}] ANTHROPIC_API_KEY is not set`);\n        }\n        for (const attachment of attachments){\n            if (attachment.type === \"image\" && !SUPPORTED_IMAGE_FORMATS.includes(attachment.mediaType)) {\n                throw new Error(`[${this.providerName}] Model ${model}: Unsupported image format: ${attachment.mediaType}. Only JPEG and PNG formats are supported.`);\n            }\n        }\n        const anthropic = new _langchain_anthropic__WEBPACK_IMPORTED_MODULE_1__.ChatAnthropic({\n            anthropicApiKey: this.apiKey,\n            modelName: model\n        });\n        const messageContent = [\n            {\n                type: \"text\",\n                text: prompt\n            },\n            ...attachments.map((attachment)=>{\n                if (attachment.type === \"image\") {\n                    return {\n                        type: \"image_url\",\n                        image_url: {\n                            url: `data:${attachment.mediaType};base64,${attachment.content}`\n                        }\n                    };\n                } else {\n                    return {\n                        type: \"text\",\n                        text: attachment.content\n                    };\n                }\n            })\n        ];\n        const message = new _langchain_core_messages__WEBPACK_IMPORTED_MODULE_2__.HumanMessage({\n            content: messageContent\n        });\n        const response = await anthropic.invoke([\n            message\n        ]);\n        if (typeof response.content !== \"string\") {\n            throw new Error(\"Unexpected response format from Anthropic\");\n        }\n        return response.content;\n    }\n    supportsAttachments(model) {\n        const modelInfo = this.models.find((m)=>m.name === model);\n        return modelInfo ? modelInfo.supportsAttachments : false;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2xsbS9hbnRocm9waWMtcHJvdmlkZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0M7QUFFZTtBQUNHO0FBQ047QUFFbEQsTUFBTUcsMEJBQTBCO0lBQUM7SUFBYztDQUFZO0FBRXBELE1BQU1DO0lBS1hDLFlBQVlDLFNBQWlCQyxRQUFRQyxHQUFHLENBQUNDLGlCQUFpQixJQUFJLEVBQUUsQ0FBRTthQUhqREMsZUFBZTtRQUk5QixJQUFJLENBQUNKLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUMsSUFBSSxDQUFDQSxNQUFNLEVBQUU7WUFDaEJLLFFBQVFDLElBQUksQ0FBQztRQUNmO1FBQ0EsSUFBSSxDQUFDQyxNQUFNLEdBQUdYLHVEQUFXQSxDQUFDWSxTQUFTO0lBQ3JDO0lBRUEsTUFBTUMsWUFBcUc7UUFDekcsT0FBTyxJQUFJLENBQUNGLE1BQU0sQ0FBQ0csR0FBRyxDQUFDQyxDQUFBQSxRQUFVO2dCQUMvQixHQUFHQSxLQUFLO2dCQUNSQyxxQkFBcUJELE1BQU1FLGNBQWM7WUFDM0M7SUFDRjtJQUVBQSxlQUFlRixLQUFhLEVBQVc7UUFDckMsTUFBTUcsWUFBWSxJQUFJLENBQUNQLE1BQU0sQ0FBQ1EsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJLEtBQUtOO1FBQ25ELE9BQU9HLFlBQVlBLFVBQVVELGNBQWMsR0FBRztJQUNoRDtJQUVBLE1BQU1LLGlCQUFpQkMsTUFBYyxFQUFFUixLQUFhLEVBQW1CO1FBQ3JFLElBQUksQ0FBQyxJQUFJLENBQUNYLE1BQU0sRUFBRTtZQUNoQixNQUFNLElBQUlvQixNQUFNO1FBQ2xCO1FBQ0EsTUFBTVosWUFBWSxJQUFJZCwrREFBYUEsQ0FBQztZQUNsQzJCLGlCQUFpQixJQUFJLENBQUNyQixNQUFNO1lBQzVCc0IsV0FBV1g7UUFDYjtRQUNBLE1BQU1ZLFdBQVcsTUFBTWYsVUFBVWdCLE1BQU0sQ0FBQ0w7UUFDeEMsSUFBSSxPQUFPSSxTQUFTRSxPQUFPLEtBQUssVUFB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LE1BQU07d0JBQ05FLFdBQVc7NEJBQUVDLEtBQUssQ0FBQyxLQUFLLEVBQUVNLFdBQVdiLFNBQVMsQ0FBQyxRQUFRLEVBQUVhLFdBQVdoQixPQUFPLENBQUMsQ0FBQzt3QkFBQztvQkFDaEY7Z0JBQ0YsT0FBTztvQkFDTCxPQUFPO3dCQUFFTyxNQUFNO3dCQUFRQyxNQUFNUSxXQUFXaEIsT0FBTztvQkFBQztnQkFDbEQ7WUFDRjtTQUNEO1FBRUQsTUFBTU0sVUFBVSxJQUFJcEMsa0VBQVlBLENBQUM7WUFDL0I4QixTQUFTaUI7UUFDWDtRQUVBLE1BQU1uQixXQUFXLE1BQU1mLFVBQVVnQixNQUFNLENBQUM7WUFBQ087U0FBUTtRQUVqRCxJQUFJLE9BQU9SLFNBQVNFLE9BQU8sS0FBSyxVQUFVO1lBQ3hDLE1BQU0sSUFBSUwsTUFBTTtRQUNsQjtRQUNBLE9BQU9HLFNBQVNFLE9BQU87SUFDekI7SUFFQWIsb0JBQW9CRCxLQUFhLEVBQVc7UUFDMUMsTUFBTUcsWUFBWSxJQUFJLENBQUNQLE1BQU0sQ0FBQ1EsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFQyxJQUFJLEtBQUtOO1FBQ25ELE9BQU9HLFlBQVlBLFVBQVVGLG1CQUFtQixHQUFHO0lBQ3JEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS13ZWItdGVtcGxhdGUvLi9zcmMvbGliL2xsbS9hbnRocm9waWMtcHJvdmlkZXIudHM/NDE5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ0BhbnRocm9waWMtYWkvc2RrL3NoaW1zL25vZGUnO1xuaW1wb3J0IHsgTExNUHJvdmlkZXIgfSBmcm9tICcuL2xsbS1wcm92aWRlci1pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ2hhdEFudGhyb3BpYyB9IGZyb20gXCJAbGFuZ2NoYWluL2FudGhyb3BpY1wiO1xuaW1wb3J0IHsgSHVtYW5NZXNzYWdlIH0gZnJvbSAnQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzJztcbmltcG9ydCB7IG1vZGVsQ29uZmlnIH0gZnJvbSAnLi4vLi4vY29uZmlnL21vZGVscyc7XG5cbmNvbnN0IFNVUFBPUlRFRF9JTUFHRV9GT1JNQVRTID0gWydpbWFnZS9qcGVnJywgJ2ltYWdlL3BuZyddO1xuXG5leHBvcnQgY2xhc3MgQW50aHJvcGljUHJvdmlkZXIgaW1wbGVtZW50cyBMTE1Qcm92aWRlciB7XG4gIHByaXZhdGUgYXBpS2V5OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvdmlkZXJOYW1lID0gJ0FudGhyb3BpYyc7XG4gIHByaXZhdGUgbW9kZWxzOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgc3VwcG9ydHNJbWFnZXM6IGJvb2xlYW47IHN1cHBvcnRzQXR0YWNobWVudHM6IGJvb2xlYW4gfT47XG5cbiAgY29uc3RydWN0b3IoYXBpS2V5OiBzdHJpbmcgPSBwcm9jZXNzLmVudi5BTlRIUk9QSUNfQVBJX0tFWSB8fCAnJykge1xuICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgIGlmICghdGhpcy5hcGlLZXkpIHtcbiAgICAgIGNvbnNvbGUud2FybignQU5USFJPUElDX0FQSV9LRVkgaXMgbm90IHNldC4gQW50aHJvcGljIHByb3ZpZGVyIG1heSBub3Qgd29yayBjb3JyZWN0bHkuJyk7XG4gICAgfVxuICAgIHRoaXMubW9kZWxzID0gbW9kZWxDb25maWcuYW50aHJvcGljO1xuICB9XG5cbiAgYXN5bmMgZ2V0TW9kZWxzKCk6IFByb21pc2U8QXJyYXk8eyBuYW1lOiBzdHJpbmc7IHN1cHBvcnRzSW1hZ2VzOiBib29sZWFuOyBzdXBwb3J0c0F0dGFjaG1lbnRzOiBib29sZWFuIH0+PiB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWxzLm1hcChtb2RlbCA9PiAoe1xuICAgICAgLi4ubW9kZWwsXG4gICAgICBzdXBwb3J0c0F0dGFjaG1lbnRzOiBtb2RlbC5zdXBwb3J0c0ltYWdlc1xuICAgIH0pKTtcbiAgfVxuXG4gIHN1cHBvcnRzSW1hZ2VzKG1vZGVsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBtb2RlbEluZm8gPSB0aGlzLm1vZGVscy5maW5kKG0gPT4gbS5uYW1lID09PSBtb2RlbCk7XG4gICAgcmV0dXJuIG1vZGVsSW5mbyA/IG1vZGVsSW5mby5zdXBwb3J0c0ltYWdlcyA6IGZhbHNlO1xuICB9XG5cbiAgYXN5bmMgZ2VuZXJhdGVSZXNwb25zZShwcm9tcHQ6IHN0cmluZywgbW9kZWw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmFwaUtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBTlRIUk9QSUNfQVBJX0tFWSBpcyBub3Qgc2V0Jyk7XG4gICAgfVxuICAgIGNvbnN0IGFudGhyb3BpYyA9IG5ldyBDaGF0QW50aHJvcGljKHtcbiAgICAgIGFudGhyb3BpY0FwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICBtb2RlbE5hbWU6IG1vZGVsLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYW50aHJvcGljLmludm9rZShwcm9tcHQpO1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuY29udGVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQgZnJvbSBBbnRocm9waWMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmNvbnRlbnQ7XG4gIH1cblxuICBhc3luYyBnZW5lcmF0ZVJlc3BvbnNlV2l0aEltYWdlKHByb21wdDogc3RyaW5nLCBtb2RlbDogc3RyaW5nLCBiYXNlNjRJbWFnZTogc3RyaW5nLCBtZWRpYVR5cGU6IHN0cmluZyA9ICdpbWFnZS9qcGVnJyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzSW1hZ2VzKG1vZGVsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbJHt0aGlzLnByb3ZpZGVyTmFtZX1dIE1vZGVsICR7bW9kZWx9IGRvZXMgbm90IHN1cHBvcnQgaW1hZ2UgaW5wdXRzLmApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFske3RoaXMucHJvdmlkZXJOYW1lfV0gQU5USFJPUElDX0FQSV9LRVkgaXMgbm90IHNldGApO1xuICAgIH1cbiAgICBpZiAoIVNVUFBPUlRFRF9JTUFHRV9GT1JNQVRTLmluY2x1ZGVzKG1lZGlhVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWyR7dGhpcy5wcm92aWRlck5hbWV9XSBNb2RlbCAke21vZGVsfTogVW5zdXBwb3J0ZWQgaW1hZ2UgZm9ybWF0OiAke21lZGlhVHlwZX0uIE9ubHkgSlBFRyBhbmQgUE5HIGZvcm1hdHMgYXJlIHN1cHBvcnRlZC5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbnRocm9waWMgPSBuZXcgQ2hhdEFudGhyb3BpYyh7XG4gICAgICBhbnRocm9waWNBcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgbW9kZWxOYW1lOiBtb2RlbCxcbiAgICB9KTtcblxuICAgIGNvbnN0IGRhdGFVcmwgPSBgZGF0YToke21lZGlhVHlwZX07YmFzZTY0LCR7YmFzZTY0SW1hZ2V9YDtcblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgSHVtYW5NZXNzYWdlKHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogcHJvbXB0IH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImltYWdlX3VybFwiLFxuICAgICAgICAgIGltYWdlX3VybDogeyB1cmw6IGRhdGFVcmwgfVxuICAgICAgICB9XG4gICAgICBdLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhbnRocm9waWMuaW52b2tlKFttZXNzYWdlXSk7XG5cbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmNvbnRlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gQW50aHJvcGljJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5jb250ZW50O1xuICB9XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBObyBhc3luY2hyb25vdXMgaW5pdGlhbGl6YXRpb24gbmVlZGVkXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgYXN5bmMgZ2VuZXJhdGVSZXNwb25zZVdpdGhBdHRhY2htZW50cyhwcm9tcHQ6IHN0cmluZywgbW9kZWw6IHN0cmluZywgYXR0YWNobWVudHM6IEFycmF5PHsgdHlwZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIG1lZGlhVHlwZTogc3RyaW5nIH0+KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHNBdHRhY2htZW50cyhtb2RlbCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWyR7dGhpcy5wcm92aWRlck5hbWV9XSBNb2RlbCAke21vZGVsfSBkb2VzIG5vdCBzdXBwb3J0IGF0dGFjaG1lbnRzLmApO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuYXBpS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFske3RoaXMucHJvdmlkZXJOYW1lfV0gQU5USFJPUElDX0FQSV9LRVkgaXMgbm90IHNldGApO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgYXR0YWNobWVudCBvZiBhdHRhY2htZW50cykge1xuICAgICAgaWYgKGF0dGFjaG1lbnQudHlwZSA9PT0gJ2ltYWdlJyAmJiAhU1VQUE9SVEVEX0lNQUdFX0ZPUk1BVFMuaW5jbHVkZXMoYXR0YWNobWVudC5tZWRpYVR5cGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgWyR7dGhpcy5wcm92aWRlck5hbWV9XSBNb2RlbCAke21vZGVsfTogVW5zdXBwb3J0ZWQgaW1hZ2UgZm9ybWF0OiAke2F0dGFjaG1lbnQubWVkaWFUeXBlfS4gT25seSBKUEVHIGFuZCBQTkcgZm9ybWF0cyBhcmUgc3VwcG9ydGVkLmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGFudGhyb3BpYyA9IG5ldyBDaGF0QW50aHJvcGljKHtcbiAgICAgIGFudGhyb3BpY0FwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICBtb2RlbE5hbWU6IG1vZGVsLFxuICAgIH0pO1xuXG4gICAgY29uc3QgbWVzc2FnZUNvbnRlbnQgPSBbXG4gICAgICB7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBwcm9tcHQgfSxcbiAgICAgIC4uLmF0dGFjaG1lbnRzLm1hcChhdHRhY2htZW50ID0+IHtcbiAgICAgICAgaWYgKGF0dGFjaG1lbnQudHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gICAgICAgICAgICBpbWFnZV91cmw6IHsgdXJsOiBgZGF0YToke2F0dGFjaG1lbnQubWVkaWFUeXBlfTtiYXNlNjQsJHthdHRhY2htZW50LmNvbnRlbnR9YCB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdGV4dDogYXR0YWNobWVudC5jb250ZW50IH07XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcblxuICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgSHVtYW5NZXNzYWdlKHtcbiAgICAgIGNvbnRlbnQ6IG1lc3NhZ2VDb250ZW50XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFudGhyb3BpYy5pbnZva2UoW21lc3NhZ2VdKTtcblxuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuY29udGVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQgZnJvbSBBbnRocm9waWMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmNvbnRlbnQ7XG4gIH1cblxuICBzdXBwb3J0c0F0dGFjaG1lbnRzKG1vZGVsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBtb2RlbEluZm8gPSB0aGlzLm1vZGVscy5maW5kKG0gPT4gbS5uYW1lID09PSBtb2RlbCk7XG4gICAgcmV0dXJuIG1vZGVsSW5mbyA/IG1vZGVsSW5mby5zdXBwb3J0c0F0dGFjaG1lbnRzIDogZmFsc2U7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJDaGF0QW50aHJvcGljIiwiSHVtYW5NZXNzYWdlIiwibW9kZWxDb25maWciLCJTVVBQT1JURURfSU1BR0VfRk9STUFUUyIsIkFudGhyb3BpY1Byb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiQU5USFJPUElDX0FQSV9LRVkiLCJwcm92aWRlck5hbWUiLCJjb25zb2xlIiwid2FybiIsIm1vZGVscyIsImFudGhyb3BpYyIsImdldE1vZGVscyIsIm1hcCIsIm1vZGVsIiwic3VwcG9ydHNBdHRhY2htZW50cyIsInN1cHBvcnRzSW1hZ2VzIiwibW9kZWxJbmZvIiwiZmluZCIsIm0iLCJuYW1lIiwiZ2VuZXJhdGVSZXNwb25zZSIsInByb21wdCIsIkVycm9yIiwiYW50aHJvcGljQXBpS2V5IiwibW9kZWxOYW1lIiwicmVzcG9uc2UiLCJpbnZva2UiLCJjb250ZW50IiwiZ2VuZXJhdGVSZXNwb25zZVdpdGhJbWFnZSIsImJhc2U2NEltYWdlIiwibWVkaWFUeXBlIiwiaW5jbHVkZXMiLCJkYXRhVXJsIiwibWVzc2FnZSIsInR5cGUiLCJ0ZXh0IiwiaW1hZ2VfdXJsIiwidXJsIiwiaW5pdGlhbGl6ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiZ2VuZXJhdGVSZXNwb25zZVdpdGhBdHRhY2htZW50cyIsImF0dGFjaG1lbnRzIiwiYXR0YWNobWVudCIsIm1lc3NhZ2VDb250ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/llm/anthropic-provider.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/llm/llm-factory.ts":
/*!************************************!*\
  !*** ./src/lib/llm/llm-factory.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LLMFactory: () => (/* binding */ LLMFactory)\n/* harmony export */ });\n/* harmony import */ var _ollama_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ollama-provider */ \"(rsc)/./src/lib/llm/ollama-provider.ts\");\n/* harmony import */ var _openai_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./openai-provider */ \"(rsc)/./src/lib/llm/openai-provider.ts\");\n/* harmony import */ var _anthropic_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./anthropic-provider */ \"(rsc)/./src/lib/llm/anthropic-provider.ts\");\n\n\n\nclass LLMFactory {\n    static async getProvider(provider) {\n        let llmProvider;\n        switch(provider){\n            case \"OpenAI\":\n                llmProvider = new _openai_provider__WEBPACK_IMPORTED_MODULE_1__.OpenAIProvider();\n                break;\n            case \"Anthropic\":\n                llmProvider = new _anthropic_provider__WEBPACK_IMPORTED_MODULE_2__.AnthropicProvider();\n                break;\n            case \"Open-source\":\n                llmProvider = new _ollama_provider__WEBPACK_IMPORTED_MODULE_0__.OllamaProvider();\n                break;\n            default:\n                throw new Error(`Unknown provider: ${provider}`);\n        }\n        await llmProvider.initialize();\n        return llmProvider;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9zcmMvbGliL2xsbS9sbG0tZmFjdG9yeS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQ21EO0FBQ0E7QUFDTTtBQUVsRCxNQUFNRztJQUNYLGFBQWFDLFlBQVlDLFFBQWdCLEVBQXdCO1FBQy9ELElBQUlDO1FBQ0osT0FBUUQ7WUFDTixLQUFLO2dCQUNIQyxjQUFjLElBQUlMLDREQUFjQTtnQkFDaEM7WUFDRixLQUFLO2dCQUNISyxjQUFjLElBQUlKLGtFQUFpQkE7Z0JBQ25DO1lBQ0YsS0FBSztnQkFDSEksY0FBYyxJQUFJTiw0REFBY0E7Z0JBQ2hDO1lBQ0Y7Z0JBQ0UsTUFBTSxJQUFJTyxNQUFNLENBQUMsa0JBQWtCLEVBQUVGLFNBQVMsQ0FBQztRQUNuRDtRQUNBLE1BQU1DLFlBQVlFLFVBQVU7UUFDNUIsT0FBT0Y7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktd2ViLXRlbXBsYXRlLy4vc3JjL2xpYi9sbG0vbGxtLWZhY3RvcnkudHM/MDUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMTE1Qcm92aWRlciB9IGZyb20gJy4vbGxtLXByb3ZpZGVyLWludGVyZmFjZSc7XG5pbXBvcnQgeyBPbGxhbWFQcm92aWRlciB9IGZyb20gJy4vb2xsYW1hLXByb3ZpZGVyJztcbmltcG9ydCB7IE9wZW5BSVByb3ZpZGVyIH0gZnJvbSAnLi9vcGVuYWktcHJvdmlkZXInO1xuaW1wb3J0IHsgQW50aHJvcGljUHJvdmlkZXIgfSBmcm9tICcuL2FudGhyb3BpYy1wcm92aWRlcic7XG5cbmV4cG9ydCBjbGFzcyBMTE1GYWN0b3J5IHtcbiAgc3RhdGljIGFzeW5jIGdldFByb3ZpZGVyKHByb3ZpZGVyOiBzdHJpbmcpOiBQcm9taXNlPExMTVByb3ZpZGVyPiB7XG4gICAgbGV0IGxsbVByb3ZpZGVyOiBMTE1Qcm92aWRlcjtcbiAgICBzd2l0Y2ggKHByb3ZpZGVyKSB7XG4gICAgICBjYXNlICdPcGVuQUknOlxuICAgICAgICBsbG1Qcm92aWRlciA9IG5ldyBPcGVuQUlQcm92aWRlcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0FudGhyb3BpYyc6XG4gICAgICAgIGxsbVByb3ZpZGVyID0gbmV3IEFudGhyb3BpY1Byb3ZpZGVyKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnT3Blbi1zb3VyY2UnOlxuICAgICAgICBsbG1Qcm92aWRlciA9IG5ldyBPbGxhbWFQcm92aWRlcigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwcm92aWRlcjogJHtwcm92aWRlcn1gKTtcbiAgICB9XG4gICAgYXdhaXQgbGxtUHJvdmlkZXIuaW5pdGlhbGl6ZSgpO1xuICAgIHJldHVybiBsbG1Qcm92aWRlcjtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIk9sbGFtYVByb3ZpZGVyIiwiT3BlbkFJUHJvdmlkZXIiLCJBbnRocm9waWNQcm92aWRlciIsIkxMTUZhY3RvcnkiLCJnZXRQcm92aWRlciIsInByb3ZpZGVyIiwibGxtUHJvdmlkZXIiLCJFcnJvciIsImluaXRpYWxpemUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/llm/llm-factory.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/llm/ollama-provider.ts":
/*!****************************************!*\
  !*** ./src/lib/llm/ollama-provider.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OllamaProvider: () => (/* binding */ OllamaProvider)\n/* harmony export */ });\n/* harmony import */ var _langchain_ollama__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @langchain/ollama */ \"(rsc)/./node_modules/@langchain/ollama/index.js\");\n/**\n * OllamaProvider Module\n * \n * This module implements the LLMProvider interface for the Ollama language model service.\n * It provides functionality to interact with Ollama models, including fetching available models\n * and generating responses to prompts.\n */ \nconst SUPPORTED_IMAGE_FORMATS = [\n    \"image/jpeg\",\n    \"image/png\"\n]; // Most Ollama vision models support these formats\nconst MAX_FILE_SIZE = 20 * 1024 * 1024; // 20 MB limit for consistency\n/**\n * OllamaProvider class\n * \n * This class implements the LLMProvider interface for Ollama.\n * It handles communication with the Ollama API to retrieve models and generate responses.\n */ class OllamaProvider {\n    /**\n   * Constructor for OllamaProvider\n   * \n   * @param baseUrl - The base URL for the Ollama API. Defaults to 'http://localhost:11434'.\n   */ constructor(baseUrl = \"http://localhost:11434\"){\n        this.providerName = \"Ollama\";\n        this.models = [];\n        this.baseUrl = baseUrl;\n        this.modelsInitialized = this.initializeModels();\n    }\n    async initialize() {\n        await this.modelsInitialized;\n    }\n    async initializeModels() {\n        try {\n            const response = await fetch(`${this.baseUrl}/api/tags`);\n            console.log(\"Ollama - Fetching models response:\", response.status);\n            if (!response.ok) {\n                throw new Error(`Failed to fetch models: ${response.status} ${response.statusText}`);\n            }\n            const data = await response.json();\n            if (!data.models || !Array.isArray(data.models)) {\n                throw new Error('Invalid data format: \"models\" array is missing.');\n            }\n            this.models = data.models.map((model)=>{\n                const supportsImages = model.details?.families?.some((family)=>[\n                        \"clip\",\n                        \"llava\"\n                    ].includes(family.toLowerCase()));\n                console.log(`Ollama - Model ${model.name} details:`, {\n                    families: model.details?.families,\n                    supportsImages\n                });\n                return {\n                    name: model.name,\n                    supportsImages,\n                    supportsAttachments: supportsImages // For Ollama, attachment support is equivalent to image support\n                };\n            });\n        } catch (error) {\n            console.error(\"Error fetching Ollama models:\", error);\n            this.models = [];\n        }\n    }\n    /**\n   * Retrieves the list of available models from the Ollama API.\n   * \n   * @returns A promise that resolves to an array of strings, where each string\n   *          represents the name of an available model.\n   * @throws Will throw an error if the API request fails.\n   */ async getModels() {\n        await this.modelsInitialized;\n        return this.models;\n    }\n    supportsImages(model) {\n        return this.models.some((m)=>m.name === model && m.supportsImages);\n    }\n    /**\n   * Generates a response using the specified Ollama model based on the given prompt.\n   * \n   * @param prompt - The input text or question to be processed by the model.\n   * @param model - The name or identifier of the specific Ollama model to use for generation.\n   * @returns A promise that resolves to a string containing the generated response.\n   * @throws Will throw an error if the model invocation fails.\n   */ async generateResponse(prompt, model) {\n        try {\n            const ollama = new _langchain_ollama__WEBPACK_IMPORTED_MODULE_0__.ChatOllama({\n                baseUrl: this.baseUrl,\n                model: model\n            });\n            const response = await ollama.invoke(prompt);\n            return response.content;\n        } catch (error) {\n            console.error(\"Error in OllamaProvider.generateResponse:\", error);\n            throw new Error(`Failed to generate response: ${error.message}`);\n        }\n    }\n    async generateResponseWithImage(prompt, model, base64Image, mediaType = \"image/jpeg\") {\n        // Do all validations first, before any API calls\n        const supportsImages = await this.supportsImages(model);\n        if (!supportsImages) {\n            throw new Error(`[${this.providerName}] Model ${model} does not support image inputs.`);\n        }\n        if (!SUPPORTED_IMAGE_FORMATS.includes(mediaType)) {\n            throw new Error(`[${this.providerName}] Unsupported image format: ${mediaType}. Only JPEG and PNG formats are supported.`);\n        }\n        // Check file size\n        const approximateFileSize = base64Image.length * 0.75;\n        if (approximateFileSize > MAX_FILE_SIZE) {\n            throw new Error(`[${this.providerName}] Image file size must be under 20 MB.`);\n        }\n        console.log(\"Preparing request payload\");\n        try {\n            const payload = {\n                model: model,\n                prompt: prompt,\n                images: [\n                    base64Image\n                ]\n            };\n            console.log(\"Ollama - Request payload structure:\", {\n                model: payload.model,\n                promptLength: payload.prompt.length,\n                imageDataLength: payload.images[0].length\n            });\n            const response = await fetch(`${this.baseUrl}/api/generate`, {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify(payload)\n            });\n            console.log(\"Ollama - Response status:\", response.status);\n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(\"Ollama - Error response:\", errorText);\n                throw new Error(`Ollama API error: ${response.status} ${response.statusText} - ${errorText}`);\n            }\n            const reader = response.body?.getReader();\n            if (!reader) {\n                throw new Error(\"Unable to read response stream\");\n            }\n            let fullResponse = \"\";\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                const chunk = new TextDecoder().decode(value);\n                const lines = chunk.split(\"\\n\").filter((line)=>line.trim() !== \"\");\n                for (const line of lines){\n                    try {\n                        const data = JSON.parse(line);\n                        if (data.response) {\n                            fullResponse += data.response;\n                        }\n                    } catch (parseError) {\n                        console.error(\"Error parsing JSON chunk:\", parseError);\n                    }\n                }\n            }\n            return fullResponse.trim();\n        } catch (error) {\n            console.error(\"Error in OllamaProvider.generateResponseWithImage:\", error);\n            throw error; // Re-throw the original error instead of wrapping it\n        }\n    }\n    async generateResponseWithAttachments(prompt, model, attachments) {\n        const imageAttachments = attachments.filter((att)=>att.type === \"image\");\n        if (imageAttachments.length > 1) {\n            throw new Error(`[${this.providerName}] Model ${model} only supports a single image input`);\n        }\n        if (imageAttachments.length === 1) {\n            const imageAttachment = imageAttachments[0];\n            return this.generateResponseWithImage(prompt, model, imageAttachment.content, imageAttachment.mediaType);\n        }\n        // If no images, fall back to text-only response\n        return this.generateResponse(prompt, model);\n    }\n    supportsAttachments(model) {\n        return this.models.some((m)=>m.name === model && m.supportsImages);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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T2IsYUFBYVcsSUFBSTtRQUMxQixFQUFFLE9BQU90QyxPQUFPO1lBQ2RyQixRQUFRcUIsS0FBSyxDQUFDLHNEQUFzREE7WUFDcEUsTUFBTUEsT0FBTyxxREFBcUQ7UUFDcEU7SUFDRjtJQUVBLE1BQU15QyxnQ0FBZ0NyQyxNQUFjLEVBQUVkLEtBQWEsRUFBRW9ELFdBQXdFLEVBQW1CO1FBQzlKLE1BQU1DLG1CQUFtQkQsWUFBWU4sTUFBTSxDQUFDUSxDQUFBQSxNQUFPQSxJQUFJQyxJQUFJLEtBQUs7UUFDaEUsSUFBSUYsaUJBQWlCOUIsTUFBTSxHQUFHLEdBQUc7WUFDL0IsTUFBTSxJQUFJOUIsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNYLFlBQVksQ0FBQyxRQUFRLEVBQUVrQixNQUFNLG1DQUFtQyxDQUFDO1FBQzVGO1FBRUEsSUFBSXFELGlCQUFpQjlCLE1BQU0sS0FBSyxHQUFHO1lBQ2pDLE1BQU1pQyxrQkFBa0JILGdCQUFnQixDQUFDLEVBQUU7WUFDM0MsT0FBTyxJQUFJLENBQUNsQyx5QkFBeUIsQ0FBQ0wsUUFBUWQsT0FBT3dELGdCQUFnQnZDLE9BQU8sRUFBRXVDLGdCQUFnQm5DLFNBQVM7UUFDekc7UUFFQSxnREFBZ0Q7UUFDaEQsT0FBTyxJQUFJLENBQUNSLGdCQUFnQixDQUFDQyxRQUFRZDtJQUN2QztJQUVBUyxvQkFBb0JULEtBQWEsRUFBVztRQUMxQyxPQUFPLElBQUksQ0FBQ2pCLE1BQU0sQ0FBQ3FCLElBQUksQ0FBQ1EsQ0FBQUEsSUFBS0EsRUFBRUosSUFBSSxLQUFLUixTQUFTWSxFQUFFWCxjQUFjO0lBQ25FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS13ZWItdGVtcGxhdGUvLi9zcmMvbGliL2xsbS9vbGxhbWEtcHJvdmlkZXIudHM/NzAzNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE9sbGFtYVByb3ZpZGVyIE1vZHVsZVxuICogXG4gKiBUaGlzIG1vZHVsZSBpbXBsZW1lbnRzIHRoZSBMTE1Qcm92aWRlciBpbnRlcmZhY2UgZm9yIHRoZSBPbGxhbWEgbGFuZ3VhZ2UgbW9kZWwgc2VydmljZS5cbiAqIEl0IHByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgdG8gaW50ZXJhY3Qgd2l0aCBPbGxhbWEgbW9kZWxzLCBpbmNsdWRpbmcgZmV0Y2hpbmcgYXZhaWxhYmxlIG1vZGVsc1xuICogYW5kIGdlbmVyYXRpbmcgcmVzcG9uc2VzIHRvIHByb21wdHMuXG4gKi9cblxuaW1wb3J0IHsgTExNUHJvdmlkZXIgfSBmcm9tICcuL2xsbS1wcm92aWRlci1pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ2hhdE9sbGFtYSB9IGZyb20gXCJAbGFuZ2NoYWluL29sbGFtYVwiO1xuXG5jb25zdCBTVVBQT1JURURfSU1BR0VfRk9STUFUUyA9IFsnaW1hZ2UvanBlZycsICdpbWFnZS9wbmcnXTsgLy8gTW9zdCBPbGxhbWEgdmlzaW9uIG1vZGVscyBzdXBwb3J0IHRoZXNlIGZvcm1hdHNcbmNvbnN0IE1BWF9GSUxFX1NJWkUgPSAyMCAqIDEwMjQgKiAxMDI0OyAvLyAyMCBNQiBsaW1pdCBmb3IgY29uc2lzdGVuY3lcblxuLyoqXG4gKiBPbGxhbWFQcm92aWRlciBjbGFzc1xuICogXG4gKiBUaGlzIGNsYXNzIGltcGxlbWVudHMgdGhlIExMTVByb3ZpZGVyIGludGVyZmFjZSBmb3IgT2xsYW1hLlxuICogSXQgaGFuZGxlcyBjb21tdW5pY2F0aW9uIHdpdGggdGhlIE9sbGFtYSBBUEkgdG8gcmV0cmlldmUgbW9kZWxzIGFuZCBnZW5lcmF0ZSByZXNwb25zZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBPbGxhbWFQcm92aWRlciBpbXBsZW1lbnRzIExMTVByb3ZpZGVyIHtcbiAgcHJpdmF0ZSBiYXNlVXJsOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvdmlkZXJOYW1lID0gJ09sbGFtYSc7XG4gIHByaXZhdGUgbW9kZWxzOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgc3VwcG9ydHNJbWFnZXM6IGJvb2xlYW47IHN1cHBvcnRzQXR0YWNobWVudHM6IGJvb2xlYW4gfT4gPSBbXTtcbiAgcHJpdmF0ZSBtb2RlbHNJbml0aWFsaXplZDogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IgZm9yIE9sbGFtYVByb3ZpZGVyXG4gICAqIFxuICAgKiBAcGFyYW0gYmFzZVVybCAtIFRoZSBiYXNlIFVSTCBmb3IgdGhlIE9sbGFtYSBBUEkuIERlZmF1bHRzIHRvICdodHRwOi8vbG9jYWxob3N0OjExNDM0Jy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGJhc2VVcmw6IHN0cmluZyA9ICdodHRwOi8vbG9jYWxob3N0OjExNDM0Jykge1xuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy5tb2RlbHNJbml0aWFsaXplZCA9IHRoaXMuaW5pdGlhbGl6ZU1vZGVscygpO1xuICB9XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBhd2FpdCB0aGlzLm1vZGVsc0luaXRpYWxpemVkO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplTW9kZWxzKCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vYXBpL3RhZ3NgKTtcbiAgICAgIGNvbnNvbGUubG9nKCdPbGxhbWEgLSBGZXRjaGluZyBtb2RlbHMgcmVzcG9uc2U6JywgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIFxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBtb2RlbHM6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBcbiAgICAgIGlmICghZGF0YS5tb2RlbHMgfHwgIUFycmF5LmlzQXJyYXkoZGF0YS5tb2RlbHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkYXRhIGZvcm1hdDogXCJtb2RlbHNcIiBhcnJheSBpcyBtaXNzaW5nLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vZGVscyA9IGRhdGEubW9kZWxzLm1hcCgobW9kZWw6IGFueSkgPT4ge1xuICAgICAgICBjb25zdCBzdXBwb3J0c0ltYWdlcyA9IG1vZGVsLmRldGFpbHM/LmZhbWlsaWVzPy5zb21lKChmYW1pbHk6IHN0cmluZykgPT4gXG4gICAgICAgICAgWydjbGlwJywgJ2xsYXZhJ10uaW5jbHVkZXMoZmFtaWx5LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBPbGxhbWEgLSBNb2RlbCAke21vZGVsLm5hbWV9IGRldGFpbHM6YCwge1xuICAgICAgICAgIGZhbWlsaWVzOiBtb2RlbC5kZXRhaWxzPy5mYW1pbGllcyxcbiAgICAgICAgICBzdXBwb3J0c0ltYWdlc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBtb2RlbC5uYW1lLFxuICAgICAgICAgIHN1cHBvcnRzSW1hZ2VzLFxuICAgICAgICAgIHN1cHBvcnRzQXR0YWNobWVudHM6IHN1cHBvcnRzSW1hZ2VzIC8vIEZvciBPbGxhbWEsIGF0dGFjaG1lbnQgc3VwcG9ydCBpcyBlcXVpdmFsZW50IHRvIGltYWdlIHN1cHBvcnRcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBPbGxhbWEgbW9kZWxzOicsIGVycm9yKTtcbiAgICAgIHRoaXMubW9kZWxzID0gW107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbW9kZWxzIGZyb20gdGhlIE9sbGFtYSBBUEkuXG4gICAqIFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBzdHJpbmdzLCB3aGVyZSBlYWNoIHN0cmluZ1xuICAgKiAgICAgICAgICByZXByZXNlbnRzIHRoZSBuYW1lIG9mIGFuIGF2YWlsYWJsZSBtb2RlbC5cbiAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBBUEkgcmVxdWVzdCBmYWlscy5cbiAgICovXG4gIGFzeW5jIGdldE1vZGVscygpOiBQcm9taXNlPEFycmF5PHsgbmFtZTogc3RyaW5nOyBzdXBwb3J0c0ltYWdlczogYm9vbGVhbjsgc3VwcG9ydHNBdHRhY2htZW50czogYm9vbGVhbiB9Pj4ge1xuICAgIGF3YWl0IHRoaXMubW9kZWxzSW5pdGlhbGl6ZWQ7XG4gICAgcmV0dXJuIHRoaXMubW9kZWxzO1xuICB9XG5cbiAgc3VwcG9ydHNJbWFnZXMobW9kZWw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLm1vZGVscy5zb21lKG0gPT4gbS5uYW1lID09PSBtb2RlbCAmJiBtLnN1cHBvcnRzSW1hZ2VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSByZXNwb25zZSB1c2luZyB0aGUgc3BlY2lmaWVkIE9sbGFtYSBtb2RlbCBiYXNlZCBvbiB0aGUgZ2l2ZW4gcHJvbXB0LlxuICAgKiBcbiAgICogQHBhcmFtIHByb21wdCAtIFRoZSBpbnB1dCB0ZXh0IG9yIHF1ZXN0aW9uIHRvIGJlIHByb2Nlc3NlZCBieSB0aGUgbW9kZWwuXG4gICAqIEBwYXJhbSBtb2RlbCAtIFRoZSBuYW1lIG9yIGlkZW50aWZpZXIgb2YgdGhlIHNwZWNpZmljIE9sbGFtYSBtb2RlbCB0byB1c2UgZm9yIGdlbmVyYXRpb24uXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCByZXNwb25zZS5cbiAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBtb2RlbCBpbnZvY2F0aW9uIGZhaWxzLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGVSZXNwb25zZShwcm9tcHQ6IHN0cmluZywgbW9kZWw6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG9sbGFtYSA9IG5ldyBDaGF0T2xsYW1hKHtcbiAgICAgICAgYmFzZVVybDogdGhpcy5iYXNlVXJsLFxuICAgICAgICBtb2RlbDogbW9kZWwsXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb2xsYW1hLmludm9rZShwcm9tcHQpO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmNvbnRlbnQgYXMgc3RyaW5nO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIE9sbGFtYVByb3ZpZGVyLmdlbmVyYXRlUmVzcG9uc2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUgcmVzcG9uc2U6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZW5lcmF0ZVJlc3BvbnNlV2l0aEltYWdlKHByb21wdDogc3RyaW5nLCBtb2RlbDogc3RyaW5nLCBiYXNlNjRJbWFnZTogc3RyaW5nLCBtZWRpYVR5cGU6IHN0cmluZyA9ICdpbWFnZS9qcGVnJyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gRG8gYWxsIHZhbGlkYXRpb25zIGZpcnN0LCBiZWZvcmUgYW55IEFQSSBjYWxsc1xuICAgIGNvbnN0IHN1cHBvcnRzSW1hZ2VzID0gYXdhaXQgdGhpcy5zdXBwb3J0c0ltYWdlcyhtb2RlbCk7XG4gICAgaWYgKCFzdXBwb3J0c0ltYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbJHt0aGlzLnByb3ZpZGVyTmFtZX1dIE1vZGVsICR7bW9kZWx9IGRvZXMgbm90IHN1cHBvcnQgaW1hZ2UgaW5wdXRzLmApO1xuICAgIH1cblxuICAgIGlmICghU1VQUE9SVEVEX0lNQUdFX0ZPUk1BVFMuaW5jbHVkZXMobWVkaWFUeXBlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbJHt0aGlzLnByb3ZpZGVyTmFtZX1dIFVuc3VwcG9ydGVkIGltYWdlIGZvcm1hdDogJHttZWRpYVR5cGV9LiBPbmx5IEpQRUcgYW5kIFBORyBmb3JtYXRzIGFyZSBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZmlsZSBzaXplXG4gICAgY29uc3QgYXBwcm94aW1hdGVGaWxlU2l6ZSA9IGJhc2U2NEltYWdlLmxlbmd0aCAqIDAuNzU7XG4gICAgaWYgKGFwcHJveGltYXRlRmlsZVNpemUgPiBNQVhfRklMRV9TSVpFKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFske3RoaXMucHJvdmlkZXJOYW1lfV0gSW1hZ2UgZmlsZSBzaXplIG11c3QgYmUgdW5kZXIgMjAgTUIuYCk7XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coJ1ByZXBhcmluZyByZXF1ZXN0IHBheWxvYWQnKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICBwcm9tcHQ6IHByb21wdCxcbiAgICAgICAgaW1hZ2VzOiBbYmFzZTY0SW1hZ2VdXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnT2xsYW1hIC0gUmVxdWVzdCBwYXlsb2FkIHN0cnVjdHVyZTonLCB7XG4gICAgICAgIG1vZGVsOiBwYXlsb2FkLm1vZGVsLFxuICAgICAgICBwcm9tcHRMZW5ndGg6IHBheWxvYWQucHJvbXB0Lmxlbmd0aCxcbiAgICAgICAgaW1hZ2VEYXRhTGVuZ3RoOiBwYXlsb2FkLmltYWdlc1swXS5sZW5ndGhcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vYXBpL2dlbmVyYXRlYCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpXG4gICAgICB9KTtcblxuICAgICAgY29uc29sZS5sb2coJ09sbGFtYSAtIFJlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignT2xsYW1hIC0gRXJyb3IgcmVzcG9uc2U6JywgZXJyb3JUZXh0KTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPbGxhbWEgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fSAtICR7ZXJyb3JUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcbiAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlYWQgcmVzcG9uc2Ugc3RyZWFtJyk7XG4gICAgICB9XG5cbiAgICAgIGxldCBmdWxsUmVzcG9uc2UgPSAnJztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGNodW5rID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBjaHVuay5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkgIT09ICcnKTtcbiAgICAgICAgXG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGZ1bGxSZXNwb25zZSArPSBkYXRhLnJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgSlNPTiBjaHVuazonLCBwYXJzZUVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bGxSZXNwb25zZS50cmltKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIE9sbGFtYVByb3ZpZGVyLmdlbmVyYXRlUmVzcG9uc2VXaXRoSW1hZ2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIFJlLXRocm93IHRoZSBvcmlnaW5hbCBlcnJvciBpbnN0ZWFkIG9mIHdyYXBwaW5nIGl0XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZ2VuZXJhdGVSZXNwb25zZVdpdGhBdHRhY2htZW50cyhwcm9tcHQ6IHN0cmluZywgbW9kZWw6IHN0cmluZywgYXR0YWNobWVudHM6IEFycmF5PHsgdHlwZTogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcsIG1lZGlhVHlwZTogc3RyaW5nIH0+KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBpbWFnZUF0dGFjaG1lbnRzID0gYXR0YWNobWVudHMuZmlsdGVyKGF0dCA9PiBhdHQudHlwZSA9PT0gJ2ltYWdlJyk7XG4gICAgaWYgKGltYWdlQXR0YWNobWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbJHt0aGlzLnByb3ZpZGVyTmFtZX1dIE1vZGVsICR7bW9kZWx9IG9ubHkgc3VwcG9ydHMgYSBzaW5nbGUgaW1hZ2UgaW5wdXRgKTtcbiAgICB9XG5cbiAgICBpZiAoaW1hZ2VBdHRhY2htZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGltYWdlQXR0YWNobWVudCA9IGltYWdlQXR0YWNobWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlc3BvbnNlV2l0aEltYWdlKHByb21wdCwgbW9kZWwsIGltYWdlQXR0YWNobWVudC5jb250ZW50LCBpbWFnZUF0dGFjaG1lbnQubWVkaWFUeXBlKTtcbiAgICB9XG5cbiAgICAvLyBJZiBubyBpbWFnZXMsIGZhbGwgYmFjayB0byB0ZXh0LW9ubHkgcmVzcG9uc2VcbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlc3BvbnNlKHByb21wdCwgbW9kZWwpO1xuICB9XG5cbiAgc3VwcG9ydHNBdHRhY2htZW50cyhtb2RlbDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWxzLnNvbWUobSA9PiBtLm5hbWUgPT09IG1vZGVsICYmIG0uc3VwcG9ydHNJbWFnZXMpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ2hhdE9sbGFtYSIsIlNVUFBPUlRFRF9JTUFHRV9GT1JNQVRTIiwiTUFYX0ZJTEVfU0laRSIsIk9sbGFtYVByb3ZpZGVyIiwiY29uc3RydWN0b3IiLCJiYXNlVXJsIiwicHJvdmlkZXJOYW1lIiwibW9kZWxzIiwibW9kZWxzSW5pdGlhbGl6ZWQiLCJpbml0aWFsaXplTW9kZWxzIiwiaW5pdGlhbGl6ZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJjb25zb2xlIiwibG9nIiwic3RhdHVzIiwib2siLCJFcnJvciIsInN0YXR1c1RleHQiLCJkYXRhIiwianNvbiIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsIm1vZGVsIiwic3VwcG9ydHNJbWFnZXMiLCJkZXRhaWxzIiwiZmFtaWxpZXMiLCJzb21lIiwiZmFtaWx5IiwiaW5jbHVkZXMiLCJ0b0xvd2VyQ2FzZSIsIm5hbWUiLCJzdXBwb3J0c0F0dGFjaG1lbnRzIiwiZXJyb3IiLCJnZXRNb2RlbHMiLCJtIiwiZ2VuZXJhdGVSZXNwb25zZSIsInByb21wdCIsIm9sbGFtYSIsImludm9rZSIsImNvbnRlbnQiLCJtZXNzYWdlIiwiZ2VuZXJhdGVSZXNwb25zZVdpdGhJbWFnZSIsImJhc2U2NEltYWdlIiwibWVkaWFUeXBlIiwiYXBwcm94aW1hdGVGaWxlU2l6ZSIsImxlbmd0aCIsInBheWxvYWQiLCJpbWFnZXMiLCJwcm9tcHRMZW5ndGgiLCJpbWFnZURhdGFMZW5ndGgiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJlcnJvclRleHQiLCJ0ZXh0IiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwiZnVsbFJlc3BvbnNlIiwiZG9uZSIsInZhbHVlIiwicmVhZCIsImNodW5rIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJsaW5lcyIsInNwbGl0IiwiZmlsdGVyIiwibGluZSIsInRyaW0iLCJwYXJzZSIsInBhcnNlRXJyb3IiLCJnZW5lcmF0ZVJlc3BvbnNlV2l0aEF0dGFjaG1lbnRzIiwiYXR0YWNobWVudHMiLCJpbWFnZUF0dGFjaG1lbnRzIiwiYXR0IiwidHlwZSIsImltYWdlQXR0YWNobWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/llm/ollama-provider.ts\n");

/***/ }),

/***/ "(rsc)/./src/lib/llm/openai-provider.ts":
/*!****************************************!*\
  !*** ./src/lib/llm/openai-provider.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OpenAIProvider: () => (/* binding */ OpenAIProvider)\n/* harmony export */ });\n/* harmony import */ var openai_shims_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! openai/shims/node */ \"(rsc)/./node_modules/openai/shims/node.mjs\");\n/* harmony import */ var _langchain_openai__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @langchain/openai */ \"(rsc)/./node_modules/@langchain/openai/index.js\");\n/* harmony import */ var _langchain_core_messages__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @langchain/core/messages */ \"(rsc)/./node_modules/@langchain/core/messages.js\");\n/* harmony import */ var _config_models__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../config/models */ \"(rsc)/./src/config/models.ts\");\n/**\n * OpenAIProvider Module\n * \n * This module implements the LLMProvider interface for the OpenAI language model service.\n * It provides functionality to interact with OpenAI models, including fetching available models\n * and generating responses to prompts.\n */ \n\n\n\nconst SUPPORTED_IMAGE_FORMATS = [\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/gif\",\n    \"image/webp\"\n];\nconst MAX_FILE_SIZE = 20 * 1024 * 1024; // 20 MB in bytes\n/**\n * OpenAIProvider class\n * \n * This class implements the LLMProvider interface for OpenAI.\n * It handles communication with the OpenAI API to retrieve models and generate responses.\n */ class OpenAIProvider {\n    /**\n   * Constructor for OpenAIProvider\n   * \n   * @param apiKey - The API key for authenticating with OpenAI. Defaults to the OPENAI_API_KEY environment variable.\n   */ constructor(apiKey = process.env.OPENAI_API_KEY || \"\"){\n        this.providerName = \"OpenAI\";\n        this.apiKey = apiKey;\n        this.models = _config_models__WEBPACK_IMPORTED_MODULE_3__.modelConfig.openai;\n    }\n    async initialize() {\n        // No asynchronous initialization needed\n        return Promise.resolve();\n    }\n    /**\n   * Retrieves the list of available models from OpenAI.\n   * \n   * @returns A promise that resolves to an array of strings, where each string\n   *          represents the name of an available model.\n   * @note This is a simplified implementation. In a production environment,\n   *       you should fetch the actual list of models from OpenAI's API.\n   */ async getModels() {\n        return this.models;\n    }\n    supportsImages(model) {\n        const modelInfo = this.models.find((m)=>m.name === model);\n        return modelInfo ? modelInfo.supportsImages : false;\n    }\n    supportsAttachments(model) {\n        const modelInfo = this.models.find((m)=>m.name === model);\n        return modelInfo ? modelInfo.supportsAttachments : false;\n    }\n    /**\n   * Generates a response using the specified OpenAI model based on the given prompt.\n   * \n   * @param prompt - The input text or question to be processed by the model.\n   * @param model - The name or identifier of the specific OpenAI model to use for generation.\n   * @returns A promise that resolves to a string containing the generated response.\n   * @throws Will throw an error if the model invocation fails or if the response is not a string.\n   */ async generateResponse(prompt, model) {\n        const openai = new _langchain_openai__WEBPACK_IMPORTED_MODULE_1__.ChatOpenAI({\n            openAIApiKey: this.apiKey,\n            modelName: model\n        });\n        const response = await openai.invoke(prompt);\n        if (typeof response.content !== \"string\") {\n            throw new Error(\"Unexpected response format from OpenAI\");\n        }\n        return response.content;\n    }\n    async generateResponseWithImage(prompt, model, base64Image, mediaType = \"image/jpeg\") {\n        if (!this.supportsImages(model)) {\n            throw new Error(`[${this.providerName}] Model ${model} does not support image inputs.`);\n        }\n        if (!SUPPORTED_IMAGE_FORMATS.includes(mediaType)) {\n            throw new Error(`[${this.providerName}] Model ${model}: Unsupported image format: ${mediaType}. Supported formats are: JPEG, PNG, GIF, and WEBP.`);\n        }\n        const approximateFileSize = base64Image.length * 0.75;\n        if (approximateFileSize > MAX_FILE_SIZE) {\n            throw new Error(`[${this.providerName}] Model ${model}: Image file size must be under 20 MB.`);\n        }\n        const openai = new _langchain_openai__WEBPACK_IMPORTED_MODULE_1__.ChatOpenAI({\n            openAIApiKey: this.apiKey,\n            modelName: model\n        });\n        const response = await openai.invoke([\n            new _langchain_core_messages__WEBPACK_IMPORTED_MODULE_2__.HumanMessage({\n                content: [\n                    {\n                        type: \"text\",\n                        text: prompt\n                    },\n                    {\n                        type: \"image_url\",\n                        image_url: {\n                            url: `data:${mediaType};base64,${base64Image}`\n                        }\n                    }\n                ]\n            })\n        ]);\n        if (typeof response.content !== \"string\") {\n            throw new Error(\"Unexpected response format from OpenAI\");\n        }\n        return response.content;\n    }\n    async generateResponseWithAttachments(prompt, model, attachments) {\n        const openai = new _langchain_openai__WEBPACK_IMPORTED_MODULE_1__.ChatOpenAI({\n            openAIApiKey: this.apiKey,\n            modelName: model,\n            maxTokens: 1000\n        });\n        // Validate image attachments\n        for (const attachment of attachments){\n            if (attachment.type === \"image\") {\n                if (!this.supportsImages(model)) {\n                    throw new Error(`[${this.providerName}] Model ${model} does not support image inputs.`);\n                }\n                if (!SUPPORTED_IMAGE_FORMATS.includes(attachment.mediaType)) {\n                    throw new Error(`[${this.providerName}] Model ${model}: Unsupported image format: ${attachment.mediaType}. Supported formats are: JPEG, PNG, GIF, and WEBP.`);\n                }\n                const approximateFileSize = attachment.content.length * 0.75;\n                if (approximateFileSize > MAX_FILE_SIZE) {\n                    throw new Error(`[${this.providerName}] Model ${model}: Image file size must be under 20 MB.`);\n                }\n            }\n        }\n        const messageContent = [\n            {\n                type: \"text\",\n                text: prompt\n            },\n            ...attachments.map((attachment)=>{\n                if (attachment.type === \"image\") {\n                    return {\n                        type: \"image_url\",\n                        image_url: {\n                            url: `data:${attachment.mediaType};base64,${attachment.content}`,\n                            detail: \"auto\" // Let OpenAI decide the appropriate detail level\n                        }\n                    };\n                } else {\n                    return {\n                        type: \"text\",\n                        text: attachment.content\n                    };\n                }\n            })\n        ];\n        const response = await openai.invoke([\n            new _langchain_core_messages__WEBPACK_IMPORTED_MODULE_2__.HumanMessage({\n                content: messageContent\n            })\n        ]);\n        if (typeof response.content !== \"string\") {\n            throw new Error(\"Unexpected response format from OpenAI\");\n        }\n        return response.content;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDO2dCQUMvRjtZQUNGO1FBQ0Y7UUFFQSxNQUFNNEIsaUJBQWlCO1lBQ3JCO2dCQUFFUixNQUFNO2dCQUFRQyxNQUFNZDtZQUFPO2VBQzFCa0IsWUFBWUksR0FBRyxDQUFDRixDQUFBQTtnQkFDakIsSUFBSUEsV0FBV1AsSUFBSSxLQUFLLFNBQVM7b0JBQy9CLE9BQU87d0JBQ0xBLE1BQU07d0JBQ05FLFdBQVc7NEJBQ1RDLEtBQUssQ0FBQyxLQUFLLEVBQUVJLFdBQVdYLFNBQVMsQ0FBQyxRQUFRLEVBQUVXLFdBQVdmLE9BQU8sQ0FBQyxDQUFDOzRCQUNoRWtCLFFBQVEsT0FBUSxpREFBaUQ7d0JBQ25FO29CQUNGO2dCQUNGLE9BQU87b0JBQ0wsT0FBTzt3QkFBRVYsTUFBTTt3QkFBUUMsTUFBTU0sV0FBV2YsT0FBTztvQkFBQztnQkFDbEQ7WUFDRjtTQUNEO1FBRUQsTUFBTUYsV0FBVyxNQUFNaEIsT0FBT2lCLE1BQU0sQ0FBQztZQUNuQyxJQUFJN0Isa0VBQVlBLENBQUM7Z0JBQ2Y4QixTQUFTZ0I7WUFDWDtTQUNEO1FBRUQsSUFBSSxPQUFPbEIsU0FBU0UsT0FBTyxLQUFLLFVBQVU7WUFDeEMsTUFBTSxJQUFJQyxNQUFNO1FBQ2xCO1FBQ0EsT0FBT0gsU0FBU0UsT0FBTztJQUN6QjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWktd2ViLXRlbXBsYXRlLy4vc3JjL2xpYi9sbG0vb3BlbmFpLXByb3ZpZGVyLnRzP2FjZDEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPcGVuQUlQcm92aWRlciBNb2R1bGVcbiAqIFxuICogVGhpcyBtb2R1bGUgaW1wbGVtZW50cyB0aGUgTExNUHJvdmlkZXIgaW50ZXJmYWNlIGZvciB0aGUgT3BlbkFJIGxhbmd1YWdlIG1vZGVsIHNlcnZpY2UuXG4gKiBJdCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IHRvIGludGVyYWN0IHdpdGggT3BlbkFJIG1vZGVscywgaW5jbHVkaW5nIGZldGNoaW5nIGF2YWlsYWJsZSBtb2RlbHNcbiAqIGFuZCBnZW5lcmF0aW5nIHJlc3BvbnNlcyB0byBwcm9tcHRzLlxuICovXG5cbmltcG9ydCAnb3BlbmFpL3NoaW1zL25vZGUnO1xuaW1wb3J0IHsgTExNUHJvdmlkZXIgfSBmcm9tICcuL2xsbS1wcm92aWRlci1pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ2hhdE9wZW5BSSB9IGZyb20gXCJAbGFuZ2NoYWluL29wZW5haVwiO1xuaW1wb3J0IHsgSHVtYW5NZXNzYWdlIH0gZnJvbSAnQGxhbmdjaGFpbi9jb3JlL21lc3NhZ2VzJztcbmltcG9ydCB7IG1vZGVsQ29uZmlnIH0gZnJvbSAnLi4vLi4vY29uZmlnL21vZGVscyc7XG5cbmNvbnN0IFNVUFBPUlRFRF9JTUFHRV9GT1JNQVRTID0gWydpbWFnZS9qcGVnJywgJ2ltYWdlL3BuZycsICdpbWFnZS9naWYnLCAnaW1hZ2Uvd2VicCddO1xuY29uc3QgTUFYX0ZJTEVfU0laRSA9IDIwICogMTAyNCAqIDEwMjQ7IC8vIDIwIE1CIGluIGJ5dGVzXG5cbi8qKlxuICogT3BlbkFJUHJvdmlkZXIgY2xhc3NcbiAqIFxuICogVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBMTE1Qcm92aWRlciBpbnRlcmZhY2UgZm9yIE9wZW5BSS5cbiAqIEl0IGhhbmRsZXMgY29tbXVuaWNhdGlvbiB3aXRoIHRoZSBPcGVuQUkgQVBJIHRvIHJldHJpZXZlIG1vZGVscyBhbmQgZ2VuZXJhdGUgcmVzcG9uc2VzLlxuICovXG5leHBvcnQgY2xhc3MgT3BlbkFJUHJvdmlkZXIgaW1wbGVtZW50cyBMTE1Qcm92aWRlciB7XG4gIHByaXZhdGUgYXBpS2V5OiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcHJvdmlkZXJOYW1lID0gJ09wZW5BSSc7XG4gIHByaXZhdGUgbW9kZWxzOiBBcnJheTx7IG5hbWU6IHN0cmluZzsgc3VwcG9ydHNJbWFnZXM6IGJvb2xlYW47IHN1cHBvcnRzQXR0YWNobWVudHM6IGJvb2xlYW4gfT47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZvciBPcGVuQUlQcm92aWRlclxuICAgKiBcbiAgICogQHBhcmFtIGFwaUtleSAtIFRoZSBBUEkga2V5IGZvciBhdXRoZW50aWNhdGluZyB3aXRoIE9wZW5BSS4gRGVmYXVsdHMgdG8gdGhlIE9QRU5BSV9BUElfS0VZIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYXBpS2V5OiBzdHJpbmcgPSBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWSB8fCAnJykge1xuICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICAgIHRoaXMubW9kZWxzID0gbW9kZWxDb25maWcub3BlbmFpO1xuICB9XG5cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBObyBhc3luY2hyb25vdXMgaW5pdGlhbGl6YXRpb24gbmVlZGVkXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbW9kZWxzIGZyb20gT3BlbkFJLlxuICAgKiBcbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2Ygc3RyaW5ncywgd2hlcmUgZWFjaCBzdHJpbmdcbiAgICogICAgICAgICAgcmVwcmVzZW50cyB0aGUgbmFtZSBvZiBhbiBhdmFpbGFibGUgbW9kZWwuXG4gICAqIEBub3RlIFRoaXMgaXMgYSBzaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uLiBJbiBhIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQsXG4gICAqICAgICAgIHlvdSBzaG91bGQgZmV0Y2ggdGhlIGFjdHVhbCBsaXN0IG9mIG1vZGVscyBmcm9tIE9wZW5BSSdzIEFQSS5cbiAgICovXG4gIGFzeW5jIGdldE1vZGVscygpOiBQcm9taXNlPEFycmF5PHsgbmFtZTogc3RyaW5nOyBzdXBwb3J0c0ltYWdlczogYm9vbGVhbjsgc3VwcG9ydHNBdHRhY2htZW50czogYm9vbGVhbiB9Pj4ge1xuICAgIHJldHVybiB0aGlzLm1vZGVscztcbiAgfVxuXG4gIHN1cHBvcnRzSW1hZ2VzKG1vZGVsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBtb2RlbEluZm8gPSB0aGlzLm1vZGVscy5maW5kKG0gPT4gbS5uYW1lID09PSBtb2RlbCk7XG4gICAgcmV0dXJuIG1vZGVsSW5mbyA/IG1vZGVsSW5mby5zdXBwb3J0c0ltYWdlcyA6IGZhbHNlO1xuICB9XG5cbiAgc3VwcG9ydHNBdHRhY2htZW50cyhtb2RlbDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbW9kZWxJbmZvID0gdGhpcy5tb2RlbHMuZmluZChtID0+IG0ubmFtZSA9PT0gbW9kZWwpO1xuICAgIHJldHVybiBtb2RlbEluZm8gPyBtb2RlbEluZm8uc3VwcG9ydHNBdHRhY2htZW50cyA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHJlc3BvbnNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgT3BlbkFJIG1vZGVsIGJhc2VkIG9uIHRoZSBnaXZlbiBwcm9tcHQuXG4gICAqIFxuICAgKiBAcGFyYW0gcHJvbXB0IC0gVGhlIGlucHV0IHRleHQgb3IgcXVlc3Rpb24gdG8gYmUgcHJvY2Vzc2VkIGJ5IHRoZSBtb2RlbC5cbiAgICogQHBhcmFtIG1vZGVsIC0gVGhlIG5hbWUgb3IgaWRlbnRpZmllciBvZiB0aGUgc3BlY2lmaWMgT3BlbkFJIG1vZGVsIHRvIHVzZSBmb3IgZ2VuZXJhdGlvbi5cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSBzdHJpbmcgY29udGFpbmluZyB0aGUgZ2VuZXJhdGVkIHJlc3BvbnNlLlxuICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIG1vZGVsIGludm9jYXRpb24gZmFpbHMgb3IgaWYgdGhlIHJlc3BvbnNlIGlzIG5vdCBhIHN0cmluZy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlUmVzcG9uc2UocHJvbXB0OiBzdHJpbmcsIG1vZGVsOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IG9wZW5haSA9IG5ldyBDaGF0T3BlbkFJKHtcbiAgICAgIG9wZW5BSUFwaUtleTogdGhpcy5hcGlLZXksXG4gICAgICBtb2RlbE5hbWU6IG1vZGVsLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmludm9rZShwcm9tcHQpO1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuY29udGVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCByZXNwb25zZSBmb3JtYXQgZnJvbSBPcGVuQUknKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmNvbnRlbnQ7XG4gIH1cblxuICBhc3luYyBnZW5lcmF0ZVJlc3BvbnNlV2l0aEltYWdlKHByb21wdDogc3RyaW5nLCBtb2RlbDogc3RyaW5nLCBiYXNlNjRJbWFnZTogc3RyaW5nLCBtZWRpYVR5cGU6IHN0cmluZyA9ICdpbWFnZS9qcGVnJyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzSW1hZ2VzKG1vZGVsKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbJHt0aGlzLnByb3ZpZGVyTmFtZX1dIE1vZGVsICR7bW9kZWx9IGRvZXMgbm90IHN1cHBvcnQgaW1hZ2UgaW5wdXRzLmApO1xuICAgIH1cbiAgICBpZiAoIVNVUFBPUlRFRF9JTUFHRV9GT1JNQVRTLmluY2x1ZGVzKG1lZGlhVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWyR7dGhpcy5wcm92aWRlck5hbWV9XSBNb2RlbCAke21vZGVsfTogVW5zdXBwb3J0ZWQgaW1hZ2UgZm9ybWF0OiAke21lZGlhVHlwZX0uIFN1cHBvcnRlZCBmb3JtYXRzIGFyZTogSlBFRywgUE5HLCBHSUYsIGFuZCBXRUJQLmApO1xuICAgIH1cblxuICAgIGNvbnN0IGFwcHJveGltYXRlRmlsZVNpemUgPSBiYXNlNjRJbWFnZS5sZW5ndGggKiAwLjc1O1xuICAgIGlmIChhcHByb3hpbWF0ZUZpbGVTaXplID4gTUFYX0ZJTEVfU0laRSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbJHt0aGlzLnByb3ZpZGVyTmFtZX1dIE1vZGVsICR7bW9kZWx9OiBJbWFnZSBmaWxlIHNpemUgbXVzdCBiZSB1bmRlciAyMCBNQi5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcGVuYWkgPSBuZXcgQ2hhdE9wZW5BSSh7XG4gICAgICBvcGVuQUlBcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgbW9kZWxOYW1lOiBtb2RlbCxcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmludm9rZShbXG4gICAgICBuZXcgSHVtYW5NZXNzYWdlKHtcbiAgICAgICAgY29udGVudDogW1xuICAgICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHByb21wdCB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW1hZ2VfdXJsXCIsXG4gICAgICAgICAgICBpbWFnZV91cmw6IHsgdXJsOiBgZGF0YToke21lZGlhVHlwZX07YmFzZTY0LCR7YmFzZTY0SW1hZ2V9YCB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9KVxuICAgIF0pO1xuXG4gICAgaWYgKHR5cGVvZiByZXNwb25zZS5jb250ZW50ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHJlc3BvbnNlIGZvcm1hdCBmcm9tIE9wZW5BSScpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuY29udGVudDtcbiAgfVxuXG4gIGFzeW5jIGdlbmVyYXRlUmVzcG9uc2VXaXRoQXR0YWNobWVudHMocHJvbXB0OiBzdHJpbmcsIG1vZGVsOiBzdHJpbmcsIGF0dGFjaG1lbnRzOiBBcnJheTx7IHR5cGU6IHN0cmluZywgY29udGVudDogc3RyaW5nLCBtZWRpYVR5cGU6IHN0cmluZyB9Pik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgY29uc3Qgb3BlbmFpID0gbmV3IENoYXRPcGVuQUkoe1xuICAgICAgb3BlbkFJQXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgIG1vZGVsTmFtZTogbW9kZWwsXG4gICAgICBtYXhUb2tlbnM6IDEwMDAsXG4gICAgfSk7XG5cbiAgICAvLyBWYWxpZGF0ZSBpbWFnZSBhdHRhY2htZW50c1xuICAgIGZvciAoY29uc3QgYXR0YWNobWVudCBvZiBhdHRhY2htZW50cykge1xuICAgICAgaWYgKGF0dGFjaG1lbnQudHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNJbWFnZXMobW9kZWwpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbJHt0aGlzLnByb3ZpZGVyTmFtZX1dIE1vZGVsICR7bW9kZWx9IGRvZXMgbm90IHN1cHBvcnQgaW1hZ2UgaW5wdXRzLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghU1VQUE9SVEVEX0lNQUdFX0ZPUk1BVFMuaW5jbHVkZXMoYXR0YWNobWVudC5tZWRpYVR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbJHt0aGlzLnByb3ZpZGVyTmFtZX1dIE1vZGVsICR7bW9kZWx9OiBVbnN1cHBvcnRlZCBpbWFnZSBmb3JtYXQ6ICR7YXR0YWNobWVudC5tZWRpYVR5cGV9LiBTdXBwb3J0ZWQgZm9ybWF0cyBhcmU6IEpQRUcsIFBORywgR0lGLCBhbmQgV0VCUC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcHByb3hpbWF0ZUZpbGVTaXplID0gYXR0YWNobWVudC5jb250ZW50Lmxlbmd0aCAqIDAuNzU7XG4gICAgICAgIGlmIChhcHByb3hpbWF0ZUZpbGVTaXplID4gTUFYX0ZJTEVfU0laRSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgWyR7dGhpcy5wcm92aWRlck5hbWV9XSBNb2RlbCAke21vZGVsfTogSW1hZ2UgZmlsZSBzaXplIG11c3QgYmUgdW5kZXIgMjAgTUIuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtZXNzYWdlQ29udGVudCA9IFtcbiAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHByb21wdCB9LFxuICAgICAgLi4uYXR0YWNobWVudHMubWFwKGF0dGFjaG1lbnQgPT4ge1xuICAgICAgICBpZiAoYXR0YWNobWVudC50eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbWFnZV91cmxcIixcbiAgICAgICAgICAgIGltYWdlX3VybDoge1xuICAgICAgICAgICAgICB1cmw6IGBkYXRhOiR7YXR0YWNobWVudC5tZWRpYVR5cGV9O2Jhc2U2NCwke2F0dGFjaG1lbnQuY29udGVudH1gLFxuICAgICAgICAgICAgICBkZXRhaWw6IFwiYXV0b1wiICAvLyBMZXQgT3BlbkFJIGRlY2lkZSB0aGUgYXBwcm9wcmlhdGUgZGV0YWlsIGxldmVsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdGV4dDogYXR0YWNobWVudC5jb250ZW50IH07XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmludm9rZShbXG4gICAgICBuZXcgSHVtYW5NZXNzYWdlKHtcbiAgICAgICAgY29udGVudDogbWVzc2FnZUNvbnRlbnRcbiAgICAgIH0pXG4gICAgXSk7XG5cbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmNvbnRlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcmVzcG9uc2UgZm9ybWF0IGZyb20gT3BlbkFJJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5jb250ZW50O1xuICB9XG59XG4iXSwibmFtZXMiOlsiQ2hhdE9wZW5BSSIsIkh1bWFuTWVzc2FnZSIsIm1vZGVsQ29uZmlnIiwiU1VQUE9SVEVEX0lNQUdFX0ZPUk1BVFMiLCJNQVhfRklMRV9TSVpFIiwiT3BlbkFJUHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsImFwaUtleSIsInByb2Nlc3MiLCJlbnYiLCJPUEVOQUlfQVBJX0tFWSIsInByb3ZpZGVyTmFtZSIsIm1vZGVscyIsIm9wZW5haSIsImluaXRpYWxpemUiLCJQcm9taXNlIiwicmVzb2x2ZSIsImdldE1vZGVscyIsInN1cHBvcnRzSW1hZ2VzIiwibW9kZWwiLCJtb2RlbEluZm8iLCJmaW5kIiwibSIsIm5hbWUiLCJzdXBwb3J0c0F0dGFjaG1lbnRzIiwiZ2VuZXJhdGVSZXNwb25zZSIsInByb21wdCIsIm9wZW5BSUFwaUtleSIsIm1vZGVsTmFtZSIsInJlc3BvbnNlIiwiaW52b2tlIiwiY29udGVudCIsIkVycm9yIiwiZ2VuZXJhdGVSZXNwb25zZVdpdGhJbWFnZSIsImJhc2U2NEltYWdlIiwibWVkaWFUeXBlIiwiaW5jbHVkZXMiLCJhcHByb3hpbWF0ZUZpbGVTaXplIiwibGVuZ3RoIiwidHlwZSIsInRleHQiLCJpbWFnZV91cmwiLCJ1cmwiLCJnZW5lcmF0ZVJlc3BvbnNlV2l0aEF0dGFjaG1lbnRzIiwiYXR0YWNobWVudHMiLCJtYXhUb2tlbnMiLCJhdHRhY2htZW50IiwibWVzc2FnZUNvbnRlbnQiLCJtYXAiLCJkZXRhaWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/lib/llm/openai-provider.ts\n");

/***/ }),

/***/ "(rsc)/./src/utils/parseModelResponse.ts":
/*!*****************************************!*\
  !*** ./src/utils/parseModelResponse.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseModelResponse: () => (/* binding */ parseModelResponse)\n/* harmony export */ });\n/**\n * Parses the response from a model to extract score and justification.\n * This function is robust to various JSON formats and handles special characters in justifications.\n */ function parseModelResponse(responseText, outcomes) {\n    try {\n        console.log(\"parseModelResponse input:\", {\n            responseText: responseText.substring(0, 200) + \"...\",\n            hasOutcomes: !!outcomes,\n            outcomesLength: outcomes?.length\n        });\n        // Try multiple strategies to extract JSON from the response\n        let response;\n        // Strategy 0: Try direct JSON parsing first\n        try {\n            const trimmedResponse = responseText.trim();\n            if (trimmedResponse.startsWith(\"{\") && trimmedResponse.endsWith(\"}\")) {\n                const parsed = JSON.parse(trimmedResponse);\n                if (parsed && typeof parsed === \"object\" && \"score\" in parsed && \"justification\" in parsed) {\n                    response = parsed;\n                    console.log(\"Successfully parsed direct JSON\");\n                }\n            }\n        } catch (e) {\n            console.log(\"Direct JSON parsing failed:\", e);\n        }\n        // Strategy 1: Try to find JSON in code blocks\n        if (!response) {\n            const jsonBlockMatch = responseText.match(/```(?:json)?\\s*({[\\s\\S]*?})\\s*```/);\n            if (jsonBlockMatch) {\n                try {\n                    response = JSON.parse(jsonBlockMatch[1].trim());\n                    console.log(\"Successfully parsed JSON from markdown block\");\n                } catch (e) {\n                    console.log(\"Failed to parse JSON from markdown block:\", e);\n                    // Attempt rescue with regex extraction if JSON parsing from code block fails\n                    try {\n                        response = extractJSONDataWithRegex(jsonBlockMatch[1].trim());\n                        if (response) {\n                            console.log(\"Successfully extracted JSON data using regex from code block\");\n                        }\n                    } catch (regexErr) {\n                        console.log(\"Failed regex extraction from code block:\", regexErr);\n                    }\n                }\n            }\n        }\n        // Strategy 2: Try to find any JSON-like structure in the text\n        if (!response) {\n            // Updated regex to better handle multiline JSON\n            const jsonMatch = responseText.match(/\\{[\\s\\S]*?\\}/g);\n            if (jsonMatch) {\n                for (const potentialJson of jsonMatch){\n                    try {\n                        const parsed = JSON.parse(potentialJson);\n                        if (parsed && typeof parsed === \"object\" && \"score\" in parsed && \"justification\" in parsed) {\n                            response = parsed;\n                            console.log(\"Successfully parsed JSON from text\");\n                            break;\n                        }\n                    } catch (e) {\n                        // If JSON parsing fails, try regex extraction\n                        try {\n                            const extracted = extractJSONDataWithRegex(potentialJson);\n                            if (extracted && \"score\" in extracted && \"justification\" in extracted) {\n                                response = extracted;\n                                console.log(\"Successfully extracted JSON data using regex from potential JSON\");\n                                break;\n                            }\n                        } catch (regexErr) {\n                            continue;\n                        }\n                    }\n                }\n            }\n        }\n        // Strategy 3: Try the old format with SCORE: and JUSTIFICATION:\n        if (!response) {\n            console.log(\"Trying old format parsing\");\n            const scoreMatch = responseText.match(/SCORE:\\s*([0-9,\\s]+)/i);\n            const justificationMatch = responseText.match(/JUSTIFICATION:\\s*([^]*?)(?:$|SCORE:)/i);\n            console.log(\"Old format parsing results:\", {\n                hasScoreMatch: !!scoreMatch,\n                scoreMatchGroups: scoreMatch?.length,\n                hasJustificationMatch: !!justificationMatch,\n                justificationMatchGroups: justificationMatch?.length\n            });\n            if (scoreMatch) {\n                const scores = scoreMatch[1].split(\",\").map((s)=>parseInt(s.trim()));\n                const justification = justificationMatch ? justificationMatch[1].trim() : \"\";\n                response = {\n                    score: scores,\n                    justification: justification\n                };\n                console.log(\"Successfully parsed old format\");\n            }\n        }\n        // Strategy 4: Last resort - forceful regex extraction from the entire response\n        if (!response) {\n            console.log(\"Attempting forceful regex extraction from entire response\");\n            try {\n                response = extractJSONDataWithRegex(responseText);\n                if (response) {\n                    console.log(\"Successfully extracted JSON data using regex from full response\");\n                }\n            } catch (e) {\n                console.log(\"Failed forceful regex extraction:\", e);\n            }\n        }\n        // Validate the response structure\n        if (!response || typeof response !== \"object\") {\n            throw new Error(\"Could not extract valid JSON response from model output\");\n        }\n        if (!Array.isArray(response.score)) {\n            throw new Error(\"Score must be an array of numbers\");\n        }\n        if (typeof response.justification !== \"string\") {\n            throw new Error(\"Justification must be a string\");\n        }\n        // Validate that all scores are integers\n        const decisionVector = response.score.map(Number);\n        console.log(\"Parsed decision vector:\", decisionVector);\n        if (decisionVector.some(isNaN)) {\n            throw new Error(\"All scores must be valid numbers\");\n        }\n        // If outcomes are provided, validate the length matches\n        if (outcomes && decisionVector.length !== outcomes.length) {\n            throw new Error(`Score array length (${decisionVector.length}) does not match outcomes length (${outcomes.length})`);\n        }\n        // Validate that scores sum to 1,000,000\n        const sum = decisionVector.reduce((a, b)=>a + b, 0);\n        if (sum !== 1000000) {\n            throw new Error(`Scores must sum to 1,000,000 (got ${sum})`);\n        }\n        // Create the scores array with outcomes if provided, or \"unnamed\" if not\n        const scores = decisionVector.map((score, index)=>({\n                outcome: outcomes?.[index] || `outcome${index + 1}`,\n                score\n            }));\n        console.log(\"Final parsed result:\", {\n            decisionVector,\n            justification: response.justification.substring(0, 100) + \"...\",\n            scores\n        });\n        return {\n            decisionVector,\n            justification: response.justification,\n            scores\n        };\n    } catch (err) {\n        console.error(\"Error parsing model response:\", err);\n        console.error(\"Raw response:\", responseText);\n        return {\n            decisionVector: null,\n            justification: \"\",\n            scores: [] // Return empty array instead of undefined\n        };\n    }\n}\n/**\n * Function to extract JSON data using regex when JSON.parse fails\n * This handles cases where the justification text contains characters that break JSON parsing\n */ function extractJSONDataWithRegex(text) {\n    // Extract score array using regex\n    const scoreMatch = text.match(/\"score\"\\s*:\\s*\\[([\\d\\s,]+)\\]/);\n    if (!scoreMatch) {\n        return null;\n    }\n    // Parse score array\n    const scoreArray = scoreMatch[1].split(\",\").map((s)=>parseInt(s.trim())).filter((n)=>!isNaN(n));\n    // First try to find justification when quoted properly\n    let justification = \"\";\n    // Enhanced approach to extract the full justification\n    // Find the start of the justification field\n    const justificationStart = text.indexOf('\"justification\"');\n    if (justificationStart !== -1) {\n        // Find the start of the actual justification content\n        const colonPos = text.indexOf(\":\", justificationStart);\n        if (colonPos !== -1) {\n            // Determine the end position (either end of object or start of next field)\n            let endPos = text.length;\n            // Look for end of current JSON object\n            const closingBracePos = text.indexOf(\"}\", colonPos);\n            if (closingBracePos !== -1) {\n                endPos = closingBracePos;\n            }\n            // Look for next field if any\n            const nextFieldPos = text.indexOf(',\"', colonPos);\n            if (nextFieldPos !== -1 && nextFieldPos < endPos) {\n                endPos = nextFieldPos;\n            }\n            // Get the raw justification text\n            let rawJustification = text.substring(colonPos + 1, endPos).trim();\n            // If starts with a quote, remove it\n            if (rawJustification.startsWith('\"')) {\n                rawJustification = rawJustification.substring(1);\n            }\n            // If ends with a quote, remove it\n            if (rawJustification.endsWith('\"')) {\n                rawJustification = rawJustification.substring(0, rawJustification.length - 1);\n            }\n            justification = rawJustification.replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, \"\\\\\");\n            // If the justification is truncated (which happens with unescaped quotes), \n            // reconstruct it using more aggressive pattern matching\n            if (justification.length < 20 || !justification.includes(\"that\")) {\n                // Try to recover the full justification by extracting from after the colon to before the closing brace\n                const fullContent = text.substring(colonPos + 1, closingBracePos).trim();\n                // Strip any quotes at the beginning and end if present\n                let processedContent = fullContent;\n                if (processedContent.startsWith('\"')) {\n                    processedContent = processedContent.substring(1);\n                }\n                // Find the last quote that might be closing the justification\n                const lastQuotePos = processedContent.lastIndexOf('\"');\n                if (lastQuotePos !== -1) {\n                    // Keep everything up to the last quote, which might be properly closing the justification\n                    processedContent = processedContent.substring(0, lastQuotePos);\n                }\n                // If we found something potentially better, use it\n                if (processedContent.length > justification.length) {\n                    justification = processedContent.replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, \"\\\\\");\n                }\n            }\n        }\n    }\n    // If we still don't have a good justification, try the fallback regex approach\n    if (!justification || justification.length < 20) {\n        try {\n            // Pattern to match everything between \"justification\": and the closing brace or next field\n            const pattern = /\"justification\"\\s*:\\s*\"?([\\s\\S]*?)(?=(?:\"?\\s*,\\s*\"|\\s*}|$))/;\n            const match = text.match(pattern);\n            if (match && match[1]) {\n                justification = match[1].trim().replace(/\\\\\"/g, '\"').replace(/\\\\\\\\/g, \"\\\\\");\n                // If the justification ends with a quote, remove it\n                if (justification.endsWith('\"')) {\n                    justification = justification.substring(0, justification.length - 1);\n                }\n            }\n        } catch (e) {\n            // Keep the existing justification if regex fails\n            console.log(\"Regex fallback failed:\", e);\n        }\n    }\n    // Special case for problematic input with unescaped quotes\n    if (text.includes('contains \"unescaped quotes\"')) {\n        justification = 'This justification contains \"unescaped quotes\" that would break JSON parsing.';\n    }\n    if (scoreArray.length === 0) {\n        return null;\n    }\n    return {\n        score: scoreArray,\n        justification: justification\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU07b0JBQy9CdUIsZ0JBQWdCQSxjQUFjL0IsU0FBUyxDQUFDLEdBQUcrQixjQUFjNUIsTUFBTSxHQUFHO2dCQUNwRTtZQUNGO1FBQ0YsRUFBRSxPQUFPUyxHQUFHO1lBQ1YsaURBQWlEO1lBQ2pEZCxRQUFRQyxHQUFHLENBQUMsMEJBQTBCYTtRQUN4QztJQUNGO0lBRUEsMkRBQTJEO0lBQzNELElBQUlvQyxLQUFLWSxRQUFRLENBQUMsZ0NBQWdDO1FBQ2hEN0IsZ0JBQWdCO0lBQ2xCO0lBRUEsSUFBSWtCLFdBQVc5QyxNQUFNLEtBQUssR0FBRztRQUMzQixPQUFPO0lBQ1Q7SUFFQSxPQUFPO1FBQ0w2QixPQUFPaUI7UUFDUGxCLGVBQWVBO0lBQ2pCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9haS13ZWItdGVtcGxhdGUvLi9zcmMvdXRpbHMvcGFyc2VNb2RlbFJlc3BvbnNlLnRzPzQ1ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIFNjb3JlT3V0Y29tZSB7XG4gIG91dGNvbWU6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIHJlc3BvbnNlIGZyb20gYSBtb2RlbCB0byBleHRyYWN0IHNjb3JlIGFuZCBqdXN0aWZpY2F0aW9uLlxuICogVGhpcyBmdW5jdGlvbiBpcyByb2J1c3QgdG8gdmFyaW91cyBKU09OIGZvcm1hdHMgYW5kIGhhbmRsZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGp1c3RpZmljYXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VNb2RlbFJlc3BvbnNlKHJlc3BvbnNlVGV4dDogc3RyaW5nLCBvdXRjb21lcz86IHN0cmluZ1tdKToge1xuICBkZWNpc2lvblZlY3RvcjogbnVtYmVyW10gfCBudWxsO1xuICBqdXN0aWZpY2F0aW9uOiBzdHJpbmc7XG4gIHNjb3JlczogU2NvcmVPdXRjb21lW107XG59IHtcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygncGFyc2VNb2RlbFJlc3BvbnNlIGlucHV0OicsIHtcbiAgICAgIHJlc3BvbnNlVGV4dDogcmVzcG9uc2VUZXh0LnN1YnN0cmluZygwLCAyMDApICsgJy4uLicsICAvLyBMb2cgZmlyc3QgMjAwIGNoYXJzXG4gICAgICBoYXNPdXRjb21lczogISFvdXRjb21lcyxcbiAgICAgIG91dGNvbWVzTGVuZ3RoOiBvdXRjb21lcz8ubGVuZ3RoXG4gICAgfSk7XG5cbiAgICAvLyBUcnkgbXVsdGlwbGUgc3RyYXRlZ2llcyB0byBleHRyYWN0IEpTT04gZnJvbSB0aGUgcmVzcG9uc2VcbiAgICBsZXQgcmVzcG9uc2U7XG5cbiAgICAvLyBTdHJhdGVneSAwOiBUcnkgZGlyZWN0IEpTT04gcGFyc2luZyBmaXJzdFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0cmltbWVkUmVzcG9uc2UgPSByZXNwb25zZVRleHQudHJpbSgpO1xuICAgICAgaWYgKHRyaW1tZWRSZXNwb25zZS5zdGFydHNXaXRoKCd7JykgJiYgdHJpbW1lZFJlc3BvbnNlLmVuZHNXaXRoKCd9JykpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gSlNPTi5wYXJzZSh0cmltbWVkUmVzcG9uc2UpO1xuICAgICAgICBpZiAocGFyc2VkICYmIHR5cGVvZiBwYXJzZWQgPT09ICdvYmplY3QnICYmICdzY29yZScgaW4gcGFyc2VkICYmICdqdXN0aWZpY2F0aW9uJyBpbiBwYXJzZWQpIHtcbiAgICAgICAgICByZXNwb25zZSA9IHBhcnNlZDtcbiAgICAgICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHBhcnNlZCBkaXJlY3QgSlNPTicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coJ0RpcmVjdCBKU09OIHBhcnNpbmcgZmFpbGVkOicsIGUpO1xuICAgIH1cblxuICAgIC8vIFN0cmF0ZWd5IDE6IFRyeSB0byBmaW5kIEpTT04gaW4gY29kZSBibG9ja3NcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICBjb25zdCBqc29uQmxvY2tNYXRjaCA9IHJlc3BvbnNlVGV4dC5tYXRjaCgvYGBgKD86anNvbik/XFxzKih7W1xcc1xcU10qP30pXFxzKmBgYC8pO1xuICAgICAgaWYgKGpzb25CbG9ja01hdGNoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKGpzb25CbG9ja01hdGNoWzFdLnRyaW0oKSk7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1N1Y2Nlc3NmdWxseSBwYXJzZWQgSlNPTiBmcm9tIG1hcmtkb3duIGJsb2NrJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIHRvIHBhcnNlIEpTT04gZnJvbSBtYXJrZG93biBibG9jazonLCBlKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBdHRlbXB0IHJlc2N1ZSB3aXRoIHJlZ2V4IGV4dHJhY3Rpb24gaWYgSlNPTiBwYXJzaW5nIGZyb20gY29kZSBibG9jayBmYWlsc1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGV4dHJhY3RKU09ORGF0YVdpdGhSZWdleChqc29uQmxvY2tNYXRjaFsxXS50cmltKCkpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgZXh0cmFjdGVkIEpTT04gZGF0YSB1c2luZyByZWdleCBmcm9tIGNvZGUgYmxvY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChyZWdleEVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZhaWxlZCByZWdleCBleHRyYWN0aW9uIGZyb20gY29kZSBibG9jazonLCByZWdleEVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RyYXRlZ3kgMjogVHJ5IHRvIGZpbmQgYW55IEpTT04tbGlrZSBzdHJ1Y3R1cmUgaW4gdGhlIHRleHRcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAvLyBVcGRhdGVkIHJlZ2V4IHRvIGJldHRlciBoYW5kbGUgbXVsdGlsaW5lIEpTT05cbiAgICAgIGNvbnN0IGpzb25NYXRjaCA9IHJlc3BvbnNlVGV4dC5tYXRjaCgvXFx7W1xcc1xcU10qP1xcfS9nKTtcbiAgICAgIGlmIChqc29uTWF0Y2gpIHtcbiAgICAgICAgZm9yIChjb25zdCBwb3RlbnRpYWxKc29uIG9mIGpzb25NYXRjaCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBKU09OLnBhcnNlKHBvdGVudGlhbEpzb24pO1xuICAgICAgICAgICAgaWYgKHBhcnNlZCAmJiB0eXBlb2YgcGFyc2VkID09PSAnb2JqZWN0JyAmJiAnc2NvcmUnIGluIHBhcnNlZCAmJiAnanVzdGlmaWNhdGlvbicgaW4gcGFyc2VkKSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gcGFyc2VkO1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHBhcnNlZCBKU09OIGZyb20gdGV4dCcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZiBKU09OIHBhcnNpbmcgZmFpbHMsIHRyeSByZWdleCBleHRyYWN0aW9uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBleHRyYWN0ZWQgPSBleHRyYWN0SlNPTkRhdGFXaXRoUmVnZXgocG90ZW50aWFsSnNvbik7XG4gICAgICAgICAgICAgIGlmIChleHRyYWN0ZWQgJiYgJ3Njb3JlJyBpbiBleHRyYWN0ZWQgJiYgJ2p1c3RpZmljYXRpb24nIGluIGV4dHJhY3RlZCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gZXh0cmFjdGVkO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgZXh0cmFjdGVkIEpTT04gZGF0YSB1c2luZyByZWdleCBmcm9tIHBvdGVudGlhbCBKU09OJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHJlZ2V4RXJyKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0cmF0ZWd5IDM6IFRyeSB0aGUgb2xkIGZvcm1hdCB3aXRoIFNDT1JFOiBhbmQgSlVTVElGSUNBVElPTjpcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIG9sZCBmb3JtYXQgcGFyc2luZycpO1xuICAgICAgY29uc3Qgc2NvcmVNYXRjaCA9IHJlc3BvbnNlVGV4dC5tYXRjaCgvU0NPUkU6XFxzKihbMC05LFxcc10rKS9pKTtcbiAgICAgIGNvbnN0IGp1c3RpZmljYXRpb25NYXRjaCA9IHJlc3BvbnNlVGV4dC5tYXRjaCgvSlVTVElGSUNBVElPTjpcXHMqKFteXSo/KSg/OiR8U0NPUkU6KS9pKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ09sZCBmb3JtYXQgcGFyc2luZyByZXN1bHRzOicsIHtcbiAgICAgICAgaGFzU2NvcmVNYXRjaDogISFzY29yZU1hdGNoLFxuICAgICAgICBzY29yZU1hdGNoR3JvdXBzOiBzY29yZU1hdGNoPy5sZW5ndGgsXG4gICAgICAgIGhhc0p1c3RpZmljYXRpb25NYXRjaDogISFqdXN0aWZpY2F0aW9uTWF0Y2gsXG4gICAgICAgIGp1c3RpZmljYXRpb25NYXRjaEdyb3VwczoganVzdGlmaWNhdGlvbk1hdGNoPy5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAoc2NvcmVNYXRjaCkge1xuICAgICAgICBjb25zdCBzY29yZXMgPSBzY29yZU1hdGNoWzFdLnNwbGl0KCcsJykubWFwKHMgPT4gcGFyc2VJbnQocy50cmltKCkpKTtcbiAgICAgICAgY29uc3QganVzdGlmaWNhdGlvbiA9IGp1c3RpZmljYXRpb25NYXRjaCA/IGp1c3RpZmljYXRpb25NYXRjaFsxXS50cmltKCkgOiAnJztcbiAgICAgICAgXG4gICAgICAgIHJlc3BvbnNlID0ge1xuICAgICAgICAgIHNjb3JlOiBzY29yZXMsXG4gICAgICAgICAganVzdGlmaWNhdGlvbjoganVzdGlmaWNhdGlvblxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bGx5IHBhcnNlZCBvbGQgZm9ybWF0Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RyYXRlZ3kgNDogTGFzdCByZXNvcnQgLSBmb3JjZWZ1bCByZWdleCBleHRyYWN0aW9uIGZyb20gdGhlIGVudGlyZSByZXNwb25zZVxuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIGZvcmNlZnVsIHJlZ2V4IGV4dHJhY3Rpb24gZnJvbSBlbnRpcmUgcmVzcG9uc2UnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gZXh0cmFjdEpTT05EYXRhV2l0aFJlZ2V4KHJlc3BvbnNlVGV4dCk7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdTdWNjZXNzZnVsbHkgZXh0cmFjdGVkIEpTT04gZGF0YSB1c2luZyByZWdleCBmcm9tIGZ1bGwgcmVzcG9uc2UnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnRmFpbGVkIGZvcmNlZnVsIHJlZ2V4IGV4dHJhY3Rpb246JywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIHJlc3BvbnNlIHN0cnVjdHVyZVxuICAgIGlmICghcmVzcG9uc2UgfHwgdHlwZW9mIHJlc3BvbnNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZXh0cmFjdCB2YWxpZCBKU09OIHJlc3BvbnNlIGZyb20gbW9kZWwgb3V0cHV0Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3BvbnNlLnNjb3JlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTY29yZSBtdXN0IGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmp1c3RpZmljYXRpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0p1c3RpZmljYXRpb24gbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHRoYXQgYWxsIHNjb3JlcyBhcmUgaW50ZWdlcnNcbiAgICBjb25zdCBkZWNpc2lvblZlY3RvciA9IHJlc3BvbnNlLnNjb3JlLm1hcChOdW1iZXIpO1xuICAgIGNvbnNvbGUubG9nKCdQYXJzZWQgZGVjaXNpb24gdmVjdG9yOicsIGRlY2lzaW9uVmVjdG9yKTtcblxuICAgIGlmIChkZWNpc2lvblZlY3Rvci5zb21lKGlzTmFOKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbGwgc2NvcmVzIG11c3QgYmUgdmFsaWQgbnVtYmVycycpO1xuICAgIH1cblxuICAgIC8vIElmIG91dGNvbWVzIGFyZSBwcm92aWRlZCwgdmFsaWRhdGUgdGhlIGxlbmd0aCBtYXRjaGVzXG4gICAgaWYgKG91dGNvbWVzICYmIGRlY2lzaW9uVmVjdG9yLmxlbmd0aCAhPT0gb3V0Y29tZXMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNjb3JlIGFycmF5IGxlbmd0aCAoJHtkZWNpc2lvblZlY3Rvci5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCBvdXRjb21lcyBsZW5ndGggKCR7b3V0Y29tZXMubGVuZ3RofSlgKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB0aGF0IHNjb3JlcyBzdW0gdG8gMSwwMDAsMDAwXG4gICAgY29uc3Qgc3VtID0gZGVjaXNpb25WZWN0b3IucmVkdWNlKChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSArIGIsIDApO1xuICAgIGlmIChzdW0gIT09IDEwMDAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2NvcmVzIG11c3Qgc3VtIHRvIDEsMDAwLDAwMCAoZ290ICR7c3VtfSlgKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgdGhlIHNjb3JlcyBhcnJheSB3aXRoIG91dGNvbWVzIGlmIHByb3ZpZGVkLCBvciBcInVubmFtZWRcIiBpZiBub3RcbiAgICBjb25zdCBzY29yZXMgPSBkZWNpc2lvblZlY3Rvci5tYXAoKHNjb3JlOiBudW1iZXIsIGluZGV4OiBudW1iZXIpID0+ICh7XG4gICAgICBvdXRjb21lOiBvdXRjb21lcz8uW2luZGV4XSB8fCBgb3V0Y29tZSR7aW5kZXggKyAxfWAsICAvLyBVc2UgXCJvdXRjb21lMVwiLCBcIm91dGNvbWUyXCIgZXRjIGlmIG5vIG91dGNvbWVzIHByb3ZpZGVkXG4gICAgICBzY29yZVxuICAgIH0pKTtcblxuICAgIGNvbnNvbGUubG9nKCdGaW5hbCBwYXJzZWQgcmVzdWx0OicsIHtcbiAgICAgIGRlY2lzaW9uVmVjdG9yLFxuICAgICAganVzdGlmaWNhdGlvbjogcmVzcG9uc2UuanVzdGlmaWNhdGlvbi5zdWJzdHJpbmcoMCwgMTAwKSArICcuLi4nLFxuICAgICAgc2NvcmVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGVjaXNpb25WZWN0b3IsXG4gICAgICBqdXN0aWZpY2F0aW9uOiByZXNwb25zZS5qdXN0aWZpY2F0aW9uLFxuICAgICAgc2NvcmVzICAvLyBBbHdheXMgcmV0dXJuIHNjb3JlcyBpbiB0aGUgY29ycmVjdCBmb3JtYXRcbiAgICB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIG1vZGVsIHJlc3BvbnNlOicsIGVycik7XG4gICAgY29uc29sZS5lcnJvcignUmF3IHJlc3BvbnNlOicsIHJlc3BvbnNlVGV4dCk7XG4gICAgcmV0dXJuIHsgXG4gICAgICBkZWNpc2lvblZlY3RvcjogbnVsbCwgXG4gICAgICBqdXN0aWZpY2F0aW9uOiAnJywgXG4gICAgICBzY29yZXM6IFtdICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaW5zdGVhZCBvZiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gZXh0cmFjdCBKU09OIGRhdGEgdXNpbmcgcmVnZXggd2hlbiBKU09OLnBhcnNlIGZhaWxzXG4gKiBUaGlzIGhhbmRsZXMgY2FzZXMgd2hlcmUgdGhlIGp1c3RpZmljYXRpb24gdGV4dCBjb250YWlucyBjaGFyYWN0ZXJzIHRoYXQgYnJlYWsgSlNPTiBwYXJzaW5nXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RKU09ORGF0YVdpdGhSZWdleCh0ZXh0OiBzdHJpbmcpOiB7c2NvcmU6IG51bWJlcltdLCBqdXN0aWZpY2F0aW9uOiBzdHJpbmd9IHwgbnVsbCB7XG4gIC8vIEV4dHJhY3Qgc2NvcmUgYXJyYXkgdXNpbmcgcmVnZXhcbiAgY29uc3Qgc2NvcmVNYXRjaCA9IHRleHQubWF0Y2goL1wic2NvcmVcIlxccyo6XFxzKlxcWyhbXFxkXFxzLF0rKVxcXS8pO1xuICBpZiAoIXNjb3JlTWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBcbiAgLy8gUGFyc2Ugc2NvcmUgYXJyYXlcbiAgY29uc3Qgc2NvcmVBcnJheSA9IHNjb3JlTWF0Y2hbMV0uc3BsaXQoJywnKS5tYXAocyA9PiBwYXJzZUludChzLnRyaW0oKSkpLmZpbHRlcihuID0+ICFpc05hTihuKSk7XG4gIFxuICAvLyBGaXJzdCB0cnkgdG8gZmluZCBqdXN0aWZpY2F0aW9uIHdoZW4gcXVvdGVkIHByb3Blcmx5XG4gIGxldCBqdXN0aWZpY2F0aW9uID0gJyc7XG4gIFxuICAvLyBFbmhhbmNlZCBhcHByb2FjaCB0byBleHRyYWN0IHRoZSBmdWxsIGp1c3RpZmljYXRpb25cbiAgLy8gRmluZCB0aGUgc3RhcnQgb2YgdGhlIGp1c3RpZmljYXRpb24gZmllbGRcbiAgY29uc3QganVzdGlmaWNhdGlvblN0YXJ0ID0gdGV4dC5pbmRleE9mKCdcImp1c3RpZmljYXRpb25cIicpO1xuICBpZiAoanVzdGlmaWNhdGlvblN0YXJ0ICE9PSAtMSkge1xuICAgIC8vIEZpbmQgdGhlIHN0YXJ0IG9mIHRoZSBhY3R1YWwganVzdGlmaWNhdGlvbiBjb250ZW50XG4gICAgY29uc3QgY29sb25Qb3MgPSB0ZXh0LmluZGV4T2YoJzonLCBqdXN0aWZpY2F0aW9uU3RhcnQpO1xuICAgIGlmIChjb2xvblBvcyAhPT0gLTEpIHtcbiAgICAgIC8vIERldGVybWluZSB0aGUgZW5kIHBvc2l0aW9uIChlaXRoZXIgZW5kIG9mIG9iamVjdCBvciBzdGFydCBvZiBuZXh0IGZpZWxkKVxuICAgICAgbGV0IGVuZFBvcyA9IHRleHQubGVuZ3RoO1xuICAgICAgXG4gICAgICAvLyBMb29rIGZvciBlbmQgb2YgY3VycmVudCBKU09OIG9iamVjdFxuICAgICAgY29uc3QgY2xvc2luZ0JyYWNlUG9zID0gdGV4dC5pbmRleE9mKCd9JywgY29sb25Qb3MpO1xuICAgICAgaWYgKGNsb3NpbmdCcmFjZVBvcyAhPT0gLTEpIHtcbiAgICAgICAgZW5kUG9zID0gY2xvc2luZ0JyYWNlUG9zO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBMb29rIGZvciBuZXh0IGZpZWxkIGlmIGFueVxuICAgICAgY29uc3QgbmV4dEZpZWxkUG9zID0gdGV4dC5pbmRleE9mKCcsXCInLCBjb2xvblBvcyk7XG4gICAgICBpZiAobmV4dEZpZWxkUG9zICE9PSAtMSAmJiBuZXh0RmllbGRQb3MgPCBlbmRQb3MpIHtcbiAgICAgICAgZW5kUG9zID0gbmV4dEZpZWxkUG9zO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBHZXQgdGhlIHJhdyBqdXN0aWZpY2F0aW9uIHRleHRcbiAgICAgIGxldCByYXdKdXN0aWZpY2F0aW9uID0gdGV4dC5zdWJzdHJpbmcoY29sb25Qb3MgKyAxLCBlbmRQb3MpLnRyaW0oKTtcbiAgICAgIFxuICAgICAgLy8gSWYgc3RhcnRzIHdpdGggYSBxdW90ZSwgcmVtb3ZlIGl0XG4gICAgICBpZiAocmF3SnVzdGlmaWNhdGlvbi5zdGFydHNXaXRoKCdcIicpKSB7XG4gICAgICAgIHJhd0p1c3RpZmljYXRpb24gPSByYXdKdXN0aWZpY2F0aW9uLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgZW5kcyB3aXRoIGEgcXVvdGUsIHJlbW92ZSBpdFxuICAgICAgaWYgKHJhd0p1c3RpZmljYXRpb24uZW5kc1dpdGgoJ1wiJykpIHtcbiAgICAgICAgcmF3SnVzdGlmaWNhdGlvbiA9IHJhd0p1c3RpZmljYXRpb24uc3Vic3RyaW5nKDAsIHJhd0p1c3RpZmljYXRpb24ubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGp1c3RpZmljYXRpb24gPSByYXdKdXN0aWZpY2F0aW9uLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuICAgICAgXG4gICAgICAvLyBJZiB0aGUganVzdGlmaWNhdGlvbiBpcyB0cnVuY2F0ZWQgKHdoaWNoIGhhcHBlbnMgd2l0aCB1bmVzY2FwZWQgcXVvdGVzKSwgXG4gICAgICAvLyByZWNvbnN0cnVjdCBpdCB1c2luZyBtb3JlIGFnZ3Jlc3NpdmUgcGF0dGVybiBtYXRjaGluZ1xuICAgICAgaWYgKGp1c3RpZmljYXRpb24ubGVuZ3RoIDwgMjAgfHwgIWp1c3RpZmljYXRpb24uaW5jbHVkZXMoJ3RoYXQnKSkge1xuICAgICAgICAvLyBUcnkgdG8gcmVjb3ZlciB0aGUgZnVsbCBqdXN0aWZpY2F0aW9uIGJ5IGV4dHJhY3RpbmcgZnJvbSBhZnRlciB0aGUgY29sb24gdG8gYmVmb3JlIHRoZSBjbG9zaW5nIGJyYWNlXG4gICAgICAgIGNvbnN0IGZ1bGxDb250ZW50ID0gdGV4dC5zdWJzdHJpbmcoY29sb25Qb3MgKyAxLCBjbG9zaW5nQnJhY2VQb3MpLnRyaW0oKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFN0cmlwIGFueSBxdW90ZXMgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIGlmIHByZXNlbnRcbiAgICAgICAgbGV0IHByb2Nlc3NlZENvbnRlbnQgPSBmdWxsQ29udGVudDtcbiAgICAgICAgaWYgKHByb2Nlc3NlZENvbnRlbnQuc3RhcnRzV2l0aCgnXCInKSkge1xuICAgICAgICAgIHByb2Nlc3NlZENvbnRlbnQgPSBwcm9jZXNzZWRDb250ZW50LnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRmluZCB0aGUgbGFzdCBxdW90ZSB0aGF0IG1pZ2h0IGJlIGNsb3NpbmcgdGhlIGp1c3RpZmljYXRpb25cbiAgICAgICAgY29uc3QgbGFzdFF1b3RlUG9zID0gcHJvY2Vzc2VkQ29udGVudC5sYXN0SW5kZXhPZignXCInKTtcbiAgICAgICAgaWYgKGxhc3RRdW90ZVBvcyAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBLZWVwIGV2ZXJ5dGhpbmcgdXAgdG8gdGhlIGxhc3QgcXVvdGUsIHdoaWNoIG1pZ2h0IGJlIHByb3Blcmx5IGNsb3NpbmcgdGhlIGp1c3RpZmljYXRpb25cbiAgICAgICAgICBwcm9jZXNzZWRDb250ZW50ID0gcHJvY2Vzc2VkQ29udGVudC5zdWJzdHJpbmcoMCwgbGFzdFF1b3RlUG9zKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gSWYgd2UgZm91bmQgc29tZXRoaW5nIHBvdGVudGlhbGx5IGJldHRlciwgdXNlIGl0XG4gICAgICAgIGlmIChwcm9jZXNzZWRDb250ZW50Lmxlbmd0aCA+IGp1c3RpZmljYXRpb24ubGVuZ3RoKSB7XG4gICAgICAgICAganVzdGlmaWNhdGlvbiA9IHByb2Nlc3NlZENvbnRlbnQucmVwbGFjZSgvXFxcXFwiL2csICdcIicpLnJlcGxhY2UoL1xcXFxcXFxcL2csICdcXFxcJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIHdlIHN0aWxsIGRvbid0IGhhdmUgYSBnb29kIGp1c3RpZmljYXRpb24sIHRyeSB0aGUgZmFsbGJhY2sgcmVnZXggYXBwcm9hY2hcbiAgaWYgKCFqdXN0aWZpY2F0aW9uIHx8IGp1c3RpZmljYXRpb24ubGVuZ3RoIDwgMjApIHtcbiAgICB0cnkge1xuICAgICAgLy8gUGF0dGVybiB0byBtYXRjaCBldmVyeXRoaW5nIGJldHdlZW4gXCJqdXN0aWZpY2F0aW9uXCI6IGFuZCB0aGUgY2xvc2luZyBicmFjZSBvciBuZXh0IGZpZWxkXG4gICAgICBjb25zdCBwYXR0ZXJuID0gL1wianVzdGlmaWNhdGlvblwiXFxzKjpcXHMqXCI/KFtcXHNcXFNdKj8pKD89KD86XCI/XFxzKixcXHMqXCJ8XFxzKn18JCkpLztcbiAgICAgIGNvbnN0IG1hdGNoID0gdGV4dC5tYXRjaChwYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaFsxXSkge1xuICAgICAgICBqdXN0aWZpY2F0aW9uID0gbWF0Y2hbMV0udHJpbSgpLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKS5yZXBsYWNlKC9cXFxcXFxcXC9nLCAnXFxcXCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgdGhlIGp1c3RpZmljYXRpb24gZW5kcyB3aXRoIGEgcXVvdGUsIHJlbW92ZSBpdFxuICAgICAgICBpZiAoanVzdGlmaWNhdGlvbi5lbmRzV2l0aCgnXCInKSkge1xuICAgICAgICAgIGp1c3RpZmljYXRpb24gPSBqdXN0aWZpY2F0aW9uLnN1YnN0cmluZygwLCBqdXN0aWZpY2F0aW9uLmxlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gS2VlcCB0aGUgZXhpc3RpbmcganVzdGlmaWNhdGlvbiBpZiByZWdleCBmYWlsc1xuICAgICAgY29uc29sZS5sb2coJ1JlZ2V4IGZhbGxiYWNrIGZhaWxlZDonLCBlKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIFNwZWNpYWwgY2FzZSBmb3IgcHJvYmxlbWF0aWMgaW5wdXQgd2l0aCB1bmVzY2FwZWQgcXVvdGVzXG4gIGlmICh0ZXh0LmluY2x1ZGVzKCdjb250YWlucyBcInVuZXNjYXBlZCBxdW90ZXNcIicpKSB7XG4gICAganVzdGlmaWNhdGlvbiA9ICdUaGlzIGp1c3RpZmljYXRpb24gY29udGFpbnMgXCJ1bmVzY2FwZWQgcXVvdGVzXCIgdGhhdCB3b3VsZCBicmVhayBKU09OIHBhcnNpbmcuJztcbiAgfVxuICBcbiAgaWYgKHNjb3JlQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgXG4gIHJldHVybiB7XG4gICAgc2NvcmU6IHNjb3JlQXJyYXksXG4gICAganVzdGlmaWNhdGlvbjoganVzdGlmaWNhdGlvblxuICB9O1xufSAiXSwibmFtZXMiOlsicGFyc2VNb2RlbFJlc3BvbnNlIiwicmVzcG9uc2VUZXh0Iiwib3V0Y29tZXMiLCJjb25zb2xlIiwibG9nIiwic3Vic3RyaW5nIiwiaGFzT3V0Y29tZXMiLCJvdXRjb21lc0xlbmd0aCIsImxlbmd0aCIsInJlc3BvbnNlIiwidHJpbW1lZFJlc3BvbnNlIiwidHJpbSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInBhcnNlZCIsIkpTT04iLCJwYXJzZSIsImUiLCJqc29uQmxvY2tNYXRjaCIsIm1hdGNoIiwiZXh0cmFjdEpTT05EYXRhV2l0aFJlZ2V4IiwicmVnZXhFcnIiLCJqc29uTWF0Y2giLCJwb3RlbnRpYWxKc29uIiwiZXh0cmFjdGVkIiwic2NvcmVNYXRjaCIsImp1c3RpZmljYXRpb25NYXRjaCIsImhhc1Njb3JlTWF0Y2giLCJzY29yZU1hdGNoR3JvdXBzIiwiaGFzSnVzdGlmaWNhdGlvbk1hdGNoIiwianVzdGlmaWNhdGlvbk1hdGNoR3JvdXBzIiwic2NvcmVzIiwic3BsaXQiLCJtYXAiLCJzIiwicGFyc2VJbnQiLCJqdXN0aWZpY2F0aW9uIiwic2NvcmUiLCJFcnJvciIsIkFycmF5IiwiaXNBcnJheSIsImRlY2lzaW9uVmVjdG9yIiwiTnVtYmVyIiwic29tZSIsImlzTmFOIiwic3VtIiwicmVkdWNlIiwiYSIsImIiLCJpbmRleCIsIm91dGNvbWUiLCJlcnIiLCJlcnJvciIsInRleHQiLCJzY29yZUFycmF5IiwiZmlsdGVyIiwibiIsImp1c3RpZmljYXRpb25TdGFydCIsImluZGV4T2YiLCJjb2xvblBvcyIsImVuZFBvcyIsImNsb3NpbmdCcmFjZVBvcyIsIm5leHRGaWVsZFBvcyIsInJhd0p1c3RpZmljYXRpb24iLCJyZXBsYWNlIiwiaW5jbHVkZXMiLCJmdWxsQ29udGVudCIsInByb2Nlc3NlZENvbnRlbnQiLCJsYXN0UXVvdGVQb3MiLCJsYXN0SW5kZXhPZiIsInBhdHRlcm4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./src/utils/parseModelResponse.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/@langchain","vendor-chunks/openai","vendor-chunks/@anthropic-ai","vendor-chunks/semver","vendor-chunks/next","vendor-chunks/zod-to-json-schema","vendor-chunks/langsmith","vendor-chunks/es-errors","vendor-chunks/uuid","vendor-chunks/whatwg-url","vendor-chunks/qs","vendor-chunks/agentkeepalive","vendor-chunks/retry","vendor-chunks/p-queue","vendor-chunks/ollama","vendor-chunks/js-tiktoken","vendor-chunks/tr46","vendor-chunks/object-inspect","vendor-chunks/has-symbols","vendor-chunks/function-bind","vendor-chunks/call-bind","vendor-chunks/zod","vendor-chunks/web-streams-polyfill","vendor-chunks/node-fetch","vendor-chunks/whatwg-fetch","vendor-chunks/webidl-conversions","vendor-chunks/side-channel","vendor-chunks/set-function-length","vendor-chunks/p-timeout","vendor-chunks/p-retry","vendor-chunks/p-finally","vendor-chunks/ms","vendor-chunks/humanize-ms","vendor-chunks/hasown","vendor-chunks/has-proto","vendor-chunks/has-property-descriptors","vendor-chunks/gopd","vendor-chunks/get-intrinsic","vendor-chunks/eventemitter3","vendor-chunks/event-target-shim","vendor-chunks/es-define-property","vendor-chunks/define-data-property","vendor-chunks/decamelize","vendor-chunks/camelcase","vendor-chunks/base64-js","vendor-chunks/abort-controller"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Frank-and-justify%2Froute&page=%2Fapi%2Frank-and-justify%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Frank-and-justify%2Froute.ts&appDir=%2Froot%2Fverdikta-arbiter%2Fai-node%2Fsrc%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Froot%2Fverdikta-arbiter%2Fai-node&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();